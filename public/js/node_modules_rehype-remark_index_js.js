"use strict";
(self["webpackChunk"] = self["webpackChunk"] || []).push([["node_modules_rehype-remark_index_js"],{

/***/ "./node_modules/extend/index.js":
/*!**************************************!*\
  !*** ./node_modules/extend/index.js ***!
  \**************************************/
/***/ ((module) => {



var hasOwn = Object.prototype.hasOwnProperty;
var toStr = Object.prototype.toString;
var defineProperty = Object.defineProperty;
var gOPD = Object.getOwnPropertyDescriptor;

var isArray = function isArray(arr) {
	if (typeof Array.isArray === 'function') {
		return Array.isArray(arr);
	}

	return toStr.call(arr) === '[object Array]';
};

var isPlainObject = function isPlainObject(obj) {
	if (!obj || toStr.call(obj) !== '[object Object]') {
		return false;
	}

	var hasOwnConstructor = hasOwn.call(obj, 'constructor');
	var hasIsPrototypeOf = obj.constructor && obj.constructor.prototype && hasOwn.call(obj.constructor.prototype, 'isPrototypeOf');
	// Not own constructor property must be Object
	if (obj.constructor && !hasOwnConstructor && !hasIsPrototypeOf) {
		return false;
	}

	// Own properties are enumerated firstly, so to speed up,
	// if last one is own, then all properties are own.
	var key;
	for (key in obj) { /**/ }

	return typeof key === 'undefined' || hasOwn.call(obj, key);
};

// If name is '__proto__', and Object.defineProperty is available, define __proto__ as an own property on target
var setProperty = function setProperty(target, options) {
	if (defineProperty && options.name === '__proto__') {
		defineProperty(target, options.name, {
			enumerable: true,
			configurable: true,
			value: options.newValue,
			writable: true
		});
	} else {
		target[options.name] = options.newValue;
	}
};

// Return undefined instead of __proto__ if '__proto__' is not an own property
var getProperty = function getProperty(obj, name) {
	if (name === '__proto__') {
		if (!hasOwn.call(obj, name)) {
			return void 0;
		} else if (gOPD) {
			// In early versions of node, obj['__proto__'] is buggy when obj has
			// __proto__ as an own property. Object.getOwnPropertyDescriptor() works.
			return gOPD(obj, name).value;
		}
	}

	return obj[name];
};

module.exports = function extend() {
	var options, name, src, copy, copyIsArray, clone;
	var target = arguments[0];
	var i = 1;
	var length = arguments.length;
	var deep = false;

	// Handle a deep copy situation
	if (typeof target === 'boolean') {
		deep = target;
		target = arguments[1] || {};
		// skip the boolean and the target
		i = 2;
	}
	if (target == null || (typeof target !== 'object' && typeof target !== 'function')) {
		target = {};
	}

	for (; i < length; ++i) {
		options = arguments[i];
		// Only deal with non-null/undefined values
		if (options != null) {
			// Extend the base object
			for (name in options) {
				src = getProperty(target, name);
				copy = getProperty(options, name);

				// Prevent never-ending loop
				if (target !== copy) {
					// Recurse if we're merging plain objects or arrays
					if (deep && copy && (isPlainObject(copy) || (copyIsArray = isArray(copy)))) {
						if (copyIsArray) {
							copyIsArray = false;
							clone = src && isArray(src) ? src : [];
						} else {
							clone = src && isPlainObject(src) ? src : {};
						}

						// Never move original objects, clone them
						setProperty(target, { name: name, newValue: extend(deep, clone, copy) });

					// Don't bring in undefined values
					} else if (typeof copy !== 'undefined') {
						setProperty(target, { name: name, newValue: copy });
					}
				}
			}
		}
	}

	// Return the modified object
	return target;
};


/***/ }),

/***/ "./node_modules/hast-util-to-mdast/lib/all.js":
/*!****************************************************!*\
  !*** ./node_modules/hast-util-to-mdast/lib/all.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   all: () => (/* binding */ all)
/* harmony export */ });
/* harmony import */ var _one_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./one.js */ "./node_modules/hast-util-to-mdast/lib/one.js");
/**
 * @typedef {import('./types.js').H} H
 * @typedef {import('./types.js').Node} Node
 * @typedef {import('./types.js').MdastNode} MdastNode
 */



/**
 * @param {H} h
 * @param {Node} parent
 * @returns {Array<MdastNode>}
 */
function all(h, parent) {
  /** @type {Array<Node>} */
  // @ts-expect-error Assume `parent` is a parent.
  const nodes = parent.children || []
  /** @type {Array<MdastNode>} */
  const values = []
  let index = -1

  while (++index < nodes.length) {
    // @ts-expect-error assume `parent` is a parent.
    const result = (0,_one_js__WEBPACK_IMPORTED_MODULE_0__.one)(h, nodes[index], parent)

    if (Array.isArray(result)) {
      values.push(...result)
    } else if (result) {
      values.push(result)
    }
  }

  let start = 0
  let end = values.length

  while (start < end && values[start].type === 'break') {
    start++
  }

  while (end > start && values[end - 1].type === 'break') {
    end--
  }

  return start === 0 && end === values.length
    ? values
    : values.slice(start, end)
}


/***/ }),

/***/ "./node_modules/hast-util-to-mdast/lib/handlers/a.js":
/*!***********************************************************!*\
  !*** ./node_modules/hast-util-to-mdast/lib/handlers/a.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   a: () => (/* binding */ a)
/* harmony export */ });
/* harmony import */ var _all_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../all.js */ "./node_modules/hast-util-to-mdast/lib/all.js");
/* harmony import */ var _util_resolve_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/resolve.js */ "./node_modules/hast-util-to-mdast/lib/util/resolve.js");
/**
 * @typedef {import('../types.js').Handle} Handle
 * @typedef {import('../types.js').Element} Element
 * @typedef {import('../types.js').Properties} Properties
 */




/**
 * @type {Handle}
 * @param {Element} node
 */
function a(h, node) {
  /** @type {Properties} */
  // @ts-expect-error: `props` are defined.
  const props = node.properties
  return h(
    node,
    'link',
    {
      title: props.title || null,
      url: (0,_util_resolve_js__WEBPACK_IMPORTED_MODULE_0__.resolve)(h, String(props.href || '') || null)
    },
    (0,_all_js__WEBPACK_IMPORTED_MODULE_1__.all)(h, node)
  )
}


/***/ }),

/***/ "./node_modules/hast-util-to-mdast/lib/handlers/base.js":
/*!**************************************************************!*\
  !*** ./node_modules/hast-util-to-mdast/lib/handlers/base.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   base: () => (/* binding */ base)
/* harmony export */ });
/**
 * @typedef {import('../types.js').Handle} Handle
 * @typedef {import('../types.js').Element} Element
 */

/**
 * @type {Handle}
 * @param {Element} node
 */
function base(h, node) {
  if (!h.baseFound) {
    h.frozenBaseUrl =
      String((node.properties && node.properties.href) || '') || null
    h.baseFound = true
  }
}


/***/ }),

/***/ "./node_modules/hast-util-to-mdast/lib/handlers/blockquote.js":
/*!********************************************************************!*\
  !*** ./node_modules/hast-util-to-mdast/lib/handlers/blockquote.js ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   blockquote: () => (/* binding */ blockquote)
/* harmony export */ });
/* harmony import */ var _util_wrap_children_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/wrap-children.js */ "./node_modules/hast-util-to-mdast/lib/util/wrap-children.js");
/**
 * @typedef {import('../types.js').Handle} Handle
 * @typedef {import('../types.js').Element} Element
 */



/**
 * @type {Handle}
 * @param {Element} node
 */
function blockquote(h, node) {
  return h(node, 'blockquote', (0,_util_wrap_children_js__WEBPACK_IMPORTED_MODULE_0__.wrapChildren)(h, node))
}


/***/ }),

/***/ "./node_modules/hast-util-to-mdast/lib/handlers/br.js":
/*!************************************************************!*\
  !*** ./node_modules/hast-util-to-mdast/lib/handlers/br.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   br: () => (/* binding */ br)
/* harmony export */ });
/**
 * @typedef {import('../types.js').Handle} Handle
 * @typedef {import('../types.js').Element} Element
 */

/**
 * @type {Handle}
 * @param {Element} node
 */
function br(h, node) {
  return h.wrapText ? h(node, 'break') : h(node, 'text', ' ')
}


/***/ }),

/***/ "./node_modules/hast-util-to-mdast/lib/handlers/code.js":
/*!**************************************************************!*\
  !*** ./node_modules/hast-util-to-mdast/lib/handlers/code.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   code: () => (/* binding */ code)
/* harmony export */ });
/* harmony import */ var hast_util_is_element__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! hast-util-is-element */ "./node_modules/hast-util-to-mdast/node_modules/hast-util-is-element/index.js");
/* harmony import */ var hast_util_to_text__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! hast-util-to-text */ "./node_modules/hast-util-to-text/lib/index.js");
/* harmony import */ var trim_trailing_lines__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! trim-trailing-lines */ "./node_modules/trim-trailing-lines/index.js");
/* harmony import */ var _util_wrap_text_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../util/wrap-text.js */ "./node_modules/hast-util-to-mdast/lib/util/wrap-text.js");
/**
 * @typedef {import('../types.js').Handle} Handle
 * @typedef {import('../types.js').Element} Element
 * @typedef {import('../types.js').ElementChild} ElementChild
 */






const prefix = 'language-'

const pre = (0,hast_util_is_element__WEBPACK_IMPORTED_MODULE_0__.convertElement)('pre')
const isCode = (0,hast_util_is_element__WEBPACK_IMPORTED_MODULE_0__.convertElement)('code')

/**
 * @type {Handle}
 * @param {Element} node
 */
function code(h, node) {
  const children = node.children
  let index = -1
  /** @type {Array<string|number>|undefined} */
  let classList
  /** @type {string|undefined} */
  let lang

  if (pre(node)) {
    while (++index < children.length) {
      const child = children[index]

      if (
        isCode(child) &&
        child.properties &&
        child.properties.className &&
        Array.isArray(child.properties.className)
      ) {
        classList = child.properties.className
        break
      }
    }
  }

  if (classList) {
    index = -1

    while (++index < classList.length) {
      if (String(classList[index]).slice(0, prefix.length) === prefix) {
        lang = String(classList[index]).slice(prefix.length)
        break
      }
    }
  }

  return h(
    node,
    'code',
    {lang: lang || null, meta: null},
    (0,trim_trailing_lines__WEBPACK_IMPORTED_MODULE_1__.trimTrailingLines)((0,_util_wrap_text_js__WEBPACK_IMPORTED_MODULE_2__.wrapText)(h, (0,hast_util_to_text__WEBPACK_IMPORTED_MODULE_3__.toText)(node)))
  )
}


/***/ }),

/***/ "./node_modules/hast-util-to-mdast/lib/handlers/comment.js":
/*!*****************************************************************!*\
  !*** ./node_modules/hast-util-to-mdast/lib/handlers/comment.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   comment: () => (/* binding */ comment)
/* harmony export */ });
/* harmony import */ var _util_wrap_text_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/wrap-text.js */ "./node_modules/hast-util-to-mdast/lib/util/wrap-text.js");
/**
 * @typedef {import('../types.js').Handle} Handle
 * @typedef {import('../types.js').Comment} Comment
 */


/**
 * @type {Handle}
 * @param {Comment} node
 */
function comment(h, node) {
  return h(node, 'html', '<!--' + (0,_util_wrap_text_js__WEBPACK_IMPORTED_MODULE_0__.wrapText)(h, node.value) + '-->')
}


/***/ }),

/***/ "./node_modules/hast-util-to-mdast/lib/handlers/del.js":
/*!*************************************************************!*\
  !*** ./node_modules/hast-util-to-mdast/lib/handlers/del.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   del: () => (/* binding */ del)
/* harmony export */ });
/* harmony import */ var _all_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../all.js */ "./node_modules/hast-util-to-mdast/lib/all.js");
/**
 * @typedef {import('../types.js').Handle} Handle
 * @typedef {import('../types.js').Element} Element
 */



/**
 * @type {Handle}
 * @param {Element} node
 */
function del(h, node) {
  return h(node, 'delete', (0,_all_js__WEBPACK_IMPORTED_MODULE_0__.all)(h, node))
}


/***/ }),

/***/ "./node_modules/hast-util-to-mdast/lib/handlers/dl.js":
/*!************************************************************!*\
  !*** ./node_modules/hast-util-to-mdast/lib/handlers/dl.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   dl: () => (/* binding */ dl)
/* harmony export */ });
/* harmony import */ var hast_util_is_element__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! hast-util-is-element */ "./node_modules/hast-util-to-mdast/node_modules/hast-util-is-element/index.js");
/* harmony import */ var _util_list_items_spread_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/list-items-spread.js */ "./node_modules/hast-util-to-mdast/lib/util/list-items-spread.js");
/* harmony import */ var _util_wrap_list_items_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../util/wrap-list-items.js */ "./node_modules/hast-util-to-mdast/lib/util/wrap-list-items.js");
/**
 * @typedef {import('../types.js').H} H
 * @typedef {import('../types.js').Handle} Handle
 * @typedef {import('../types.js').Element} Element
 * @typedef {import('../types.js').ElementChild} ElementChild
 * @typedef {import('../types.js').MdastNode} MdastNode
 * @typedef {import('../types.js').MdastListContent} MdastListContent
 * @typedef {import('../types.js').MdastBlockContent} MdastBlockContent
 * @typedef {import('../types.js').MdastDefinitionContent} MdastDefinitionContent
 *
 * @typedef Group
 * @property {Array<Element>} titles
 * @property {Array<ElementChild>} definitions
 */





const div = (0,hast_util_is_element__WEBPACK_IMPORTED_MODULE_0__.convertElement)('div')
const dt = (0,hast_util_is_element__WEBPACK_IMPORTED_MODULE_0__.convertElement)('dt')
const dd = (0,hast_util_is_element__WEBPACK_IMPORTED_MODULE_0__.convertElement)('dd')

/**
 * @type {Handle}
 * @param {Element} node
 */
function dl(h, node) {
  const children = node.children
  let index = -1
  /** @type {Array<ElementChild>} */
  let clean = []
  /** @type {Array<Group>} */
  const groups = []
  /** @type {Group} */
  let group = {titles: [], definitions: []}
  /** @type {ElementChild} */
  let child
  /** @type {Array<MdastBlockContent|MdastDefinitionContent>} */
  let result

  // Unwrap `<div>`s
  while (++index < children.length) {
    child = children[index]
    clean = clean.concat(div(child) ? child.children : child)
  }

  index = -1

  // Group titles and definitions.
  while (++index < clean.length) {
    child = clean[index]

    if (dt(child)) {
      if (dd(clean[index - 1])) {
        groups.push(group)
        group = {titles: [], definitions: []}
      }

      group.titles.push(child)
    } else {
      group.definitions.push(child)
    }
  }

  groups.push(group)

  // Create items.
  index = -1
  /** @type {Array<MdastListContent>} */
  const content = []

  while (++index < groups.length) {
    result = [
      ...handle(h, groups[index].titles),
      ...handle(h, groups[index].definitions)
    ]

    if (result.length > 0) {
      content.push({
        type: 'listItem',
        spread: result.length > 1,
        checked: null,
        children: result
      })
    }
  }

  // Create a list if there are items.
  if (content.length > 0) {
    return h(
      node,
      'list',
      {ordered: false, start: null, spread: (0,_util_list_items_spread_js__WEBPACK_IMPORTED_MODULE_1__.listItemsSpread)(content)},
      content
    )
  }
}

/**
 * @param {H} h
 * @param {Array<ElementChild>} children
 * @returns {Array<MdastBlockContent|MdastDefinitionContent>}
 */
function handle(h, children) {
  const nodes = (0,_util_wrap_list_items_js__WEBPACK_IMPORTED_MODULE_2__.wrapListItems)(h, {type: 'element', tagName: 'x', children})

  if (nodes.length === 0) {
    return []
  }

  if (nodes.length === 1) {
    return nodes[0].children
  }

  return [
    {
      type: 'list',
      ordered: false,
      start: null,
      spread: (0,_util_list_items_spread_js__WEBPACK_IMPORTED_MODULE_1__.listItemsSpread)(nodes),
      children: nodes
    }
  ]
}


/***/ }),

/***/ "./node_modules/hast-util-to-mdast/lib/handlers/em.js":
/*!************************************************************!*\
  !*** ./node_modules/hast-util-to-mdast/lib/handlers/em.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   em: () => (/* binding */ em)
/* harmony export */ });
/* harmony import */ var _all_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../all.js */ "./node_modules/hast-util-to-mdast/lib/all.js");
/**
 * @typedef {import('../types.js').Handle} Handle
 * @typedef {import('../types.js').Element} Element
 */



/**
 * @type {Handle}
 * @param {Element} node
 */
function em(h, node) {
  return h(node, 'emphasis', (0,_all_js__WEBPACK_IMPORTED_MODULE_0__.all)(h, node))
}


/***/ }),

/***/ "./node_modules/hast-util-to-mdast/lib/handlers/heading.js":
/*!*****************************************************************!*\
  !*** ./node_modules/hast-util-to-mdast/lib/handlers/heading.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   heading: () => (/* binding */ heading)
/* harmony export */ });
/* harmony import */ var _all_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../all.js */ "./node_modules/hast-util-to-mdast/lib/all.js");
/**
 * @typedef {import('../types.js').Handle} Handle
 * @typedef {import('../types.js').Element} Element
 * @typedef {import('../types.js').MdastNode} MdastNode
 */



/**
 * @type {Handle}
 * @param {Element} node
 */
function heading(h, node) {
  // `else` shouldn’t happen, of course…
  /* c8 ignore next */
  const depth = Number(node.tagName.charAt(1)) || 1
  const wrap = h.wrapText

  h.wrapText = false
  const result = h(node, 'heading', {depth}, (0,_all_js__WEBPACK_IMPORTED_MODULE_0__.all)(h, node))
  h.wrapText = wrap

  return result
}


/***/ }),

/***/ "./node_modules/hast-util-to-mdast/lib/handlers/hr.js":
/*!************************************************************!*\
  !*** ./node_modules/hast-util-to-mdast/lib/handlers/hr.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   hr: () => (/* binding */ hr)
/* harmony export */ });
/**
 * @typedef {import('../types.js').Handle} Handle
 * @typedef {import('../types.js').Element} Element
 */

/**
 * @type {Handle}
 * @param {Element} node
 */
function hr(h, node) {
  return h(node, 'thematicBreak')
}


/***/ }),

/***/ "./node_modules/hast-util-to-mdast/lib/handlers/iframe.js":
/*!****************************************************************!*\
  !*** ./node_modules/hast-util-to-mdast/lib/handlers/iframe.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   iframe: () => (/* binding */ iframe)
/* harmony export */ });
/* harmony import */ var _util_resolve_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/resolve.js */ "./node_modules/hast-util-to-mdast/lib/util/resolve.js");
/* harmony import */ var _util_wrap_text_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/wrap-text.js */ "./node_modules/hast-util-to-mdast/lib/util/wrap-text.js");
/**
 * @typedef {import('../types.js').Handle} Handle
 * @typedef {import('../types.js').Element} Element
 * @typedef {import('../types.js').Properties} Properties
 */




/**
 * @type {Handle}
 * @param {Element} node
 */
function iframe(h, node) {
  /** @type {Properties} */
  // @ts-expect-error: `props` are defined.
  const props = node.properties
  const src = String(props.src || '')
  const title = String(props.title || '')

  // Only create a link if there is a title.
  // We can’t use the content of the frame because conforming HTML parsers treat
  // it as text, whereas legacy parsers treat it as HTML, so it will likely
  // contain tags that will show up in text.
  if (src && title) {
    return {
      type: 'link',
      title: null,
      url: (0,_util_resolve_js__WEBPACK_IMPORTED_MODULE_0__.resolve)(h, src),
      children: [{type: 'text', value: (0,_util_wrap_text_js__WEBPACK_IMPORTED_MODULE_1__.wrapText)(h, title)}]
    }
  }
}


/***/ }),

/***/ "./node_modules/hast-util-to-mdast/lib/handlers/img.js":
/*!*************************************************************!*\
  !*** ./node_modules/hast-util-to-mdast/lib/handlers/img.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   img: () => (/* binding */ img)
/* harmony export */ });
/* harmony import */ var _util_resolve_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/resolve.js */ "./node_modules/hast-util-to-mdast/lib/util/resolve.js");
/**
 * @typedef {import('../types.js').Handle} Handle
 * @typedef {import('../types.js').Element} Element
 * @typedef {import('../types.js').Properties} Properties
 */



/**
 * @type {Handle}
 * @param {Element} node
 */
function img(h, node) {
  /** @type {Properties} */
  // @ts-expect-error: `props` are defined.
  const props = node.properties
  return h(node, 'image', {
    url: (0,_util_resolve_js__WEBPACK_IMPORTED_MODULE_0__.resolve)(h, String(props.src || '') || null),
    title: props.title || null,
    alt: props.alt || ''
  })
}


/***/ }),

/***/ "./node_modules/hast-util-to-mdast/lib/handlers/index.js":
/*!***************************************************************!*\
  !*** ./node_modules/hast-util-to-mdast/lib/handlers/index.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   handlers: () => (/* binding */ handlers)
/* harmony export */ });
/* harmony import */ var _all_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../all.js */ "./node_modules/hast-util-to-mdast/lib/all.js");
/* harmony import */ var _util_wrap_children_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../util/wrap-children.js */ "./node_modules/hast-util-to-mdast/lib/util/wrap-children.js");
/* harmony import */ var _a_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./a.js */ "./node_modules/hast-util-to-mdast/lib/handlers/a.js");
/* harmony import */ var _base_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./base.js */ "./node_modules/hast-util-to-mdast/lib/handlers/base.js");
/* harmony import */ var _blockquote_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./blockquote.js */ "./node_modules/hast-util-to-mdast/lib/handlers/blockquote.js");
/* harmony import */ var _br_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./br.js */ "./node_modules/hast-util-to-mdast/lib/handlers/br.js");
/* harmony import */ var _code_js__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ./code.js */ "./node_modules/hast-util-to-mdast/lib/handlers/code.js");
/* harmony import */ var _comment_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./comment.js */ "./node_modules/hast-util-to-mdast/lib/handlers/comment.js");
/* harmony import */ var _del_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./del.js */ "./node_modules/hast-util-to-mdast/lib/handlers/del.js");
/* harmony import */ var _dl_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./dl.js */ "./node_modules/hast-util-to-mdast/lib/handlers/dl.js");
/* harmony import */ var _em_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./em.js */ "./node_modules/hast-util-to-mdast/lib/handlers/em.js");
/* harmony import */ var _heading_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./heading.js */ "./node_modules/hast-util-to-mdast/lib/handlers/heading.js");
/* harmony import */ var _hr_js__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./hr.js */ "./node_modules/hast-util-to-mdast/lib/handlers/hr.js");
/* harmony import */ var _iframe_js__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./iframe.js */ "./node_modules/hast-util-to-mdast/lib/handlers/iframe.js");
/* harmony import */ var _img_js__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./img.js */ "./node_modules/hast-util-to-mdast/lib/handlers/img.js");
/* harmony import */ var _inline_code_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./inline-code.js */ "./node_modules/hast-util-to-mdast/lib/handlers/inline-code.js");
/* harmony import */ var _input_js__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./input.js */ "./node_modules/hast-util-to-mdast/lib/handlers/input.js");
/* harmony import */ var _li_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./li.js */ "./node_modules/hast-util-to-mdast/lib/handlers/li.js");
/* harmony import */ var _list_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./list.js */ "./node_modules/hast-util-to-mdast/lib/handlers/list.js");
/* harmony import */ var _media_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./media.js */ "./node_modules/hast-util-to-mdast/lib/handlers/media.js");
/* harmony import */ var _p_js__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ./p.js */ "./node_modules/hast-util-to-mdast/lib/handlers/p.js");
/* harmony import */ var _q_js__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! ./q.js */ "./node_modules/hast-util-to-mdast/lib/handlers/q.js");
/* harmony import */ var _root_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./root.js */ "./node_modules/hast-util-to-mdast/lib/handlers/root.js");
/* harmony import */ var _select_js__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! ./select.js */ "./node_modules/hast-util-to-mdast/lib/handlers/select.js");
/* harmony import */ var _strong_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./strong.js */ "./node_modules/hast-util-to-mdast/lib/handlers/strong.js");
/* harmony import */ var _table_cell_js__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(/*! ./table-cell.js */ "./node_modules/hast-util-to-mdast/lib/handlers/table-cell.js");
/* harmony import */ var _table_row_js__WEBPACK_IMPORTED_MODULE_29__ = __webpack_require__(/*! ./table-row.js */ "./node_modules/hast-util-to-mdast/lib/handlers/table-row.js");
/* harmony import */ var _table_js__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! ./table.js */ "./node_modules/hast-util-to-mdast/lib/handlers/table.js");
/* harmony import */ var _text_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./text.js */ "./node_modules/hast-util-to-mdast/lib/handlers/text.js");
/* harmony import */ var _textarea_js__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__(/*! ./textarea.js */ "./node_modules/hast-util-to-mdast/lib/handlers/textarea.js");
/* harmony import */ var _wbr_js__WEBPACK_IMPORTED_MODULE_30__ = __webpack_require__(/*! ./wbr.js */ "./node_modules/hast-util-to-mdast/lib/handlers/wbr.js");
































const handlers = {
  root: _root_js__WEBPACK_IMPORTED_MODULE_0__.root,
  text: _text_js__WEBPACK_IMPORTED_MODULE_1__.text,
  comment: _comment_js__WEBPACK_IMPORTED_MODULE_2__.comment,
  doctype: ignore,

  applet: ignore,
  area: ignore,
  basefont: ignore,
  bgsound: ignore,
  caption: ignore,
  col: ignore,
  colgroup: ignore,
  command: ignore,
  content: ignore,
  datalist: ignore,
  dialog: ignore,
  element: ignore,
  embed: ignore,
  frame: ignore,
  frameset: ignore,
  isindex: ignore,
  keygen: ignore,
  link: ignore,
  math: ignore,
  menu: ignore,
  menuitem: ignore,
  meta: ignore,
  nextid: ignore,
  noembed: ignore,
  noframes: ignore,
  optgroup: ignore,
  option: ignore,
  param: ignore,
  script: ignore,
  shadow: ignore,
  source: ignore,
  spacer: ignore,
  style: ignore,
  svg: ignore,
  template: ignore,
  title: ignore,
  track: ignore,

  abbr: _all_js__WEBPACK_IMPORTED_MODULE_3__.all,
  acronym: _all_js__WEBPACK_IMPORTED_MODULE_3__.all,
  bdi: _all_js__WEBPACK_IMPORTED_MODULE_3__.all,
  bdo: _all_js__WEBPACK_IMPORTED_MODULE_3__.all,
  big: _all_js__WEBPACK_IMPORTED_MODULE_3__.all,
  blink: _all_js__WEBPACK_IMPORTED_MODULE_3__.all,
  button: _all_js__WEBPACK_IMPORTED_MODULE_3__.all,
  canvas: _all_js__WEBPACK_IMPORTED_MODULE_3__.all,
  cite: _all_js__WEBPACK_IMPORTED_MODULE_3__.all,
  data: _all_js__WEBPACK_IMPORTED_MODULE_3__.all,
  details: _all_js__WEBPACK_IMPORTED_MODULE_3__.all,
  dfn: _all_js__WEBPACK_IMPORTED_MODULE_3__.all,
  font: _all_js__WEBPACK_IMPORTED_MODULE_3__.all,
  ins: _all_js__WEBPACK_IMPORTED_MODULE_3__.all,
  label: _all_js__WEBPACK_IMPORTED_MODULE_3__.all,
  map: _all_js__WEBPACK_IMPORTED_MODULE_3__.all,
  marquee: _all_js__WEBPACK_IMPORTED_MODULE_3__.all,
  meter: _all_js__WEBPACK_IMPORTED_MODULE_3__.all,
  nobr: _all_js__WEBPACK_IMPORTED_MODULE_3__.all,
  noscript: _all_js__WEBPACK_IMPORTED_MODULE_3__.all,
  object: _all_js__WEBPACK_IMPORTED_MODULE_3__.all,
  output: _all_js__WEBPACK_IMPORTED_MODULE_3__.all,
  progress: _all_js__WEBPACK_IMPORTED_MODULE_3__.all,
  rb: _all_js__WEBPACK_IMPORTED_MODULE_3__.all,
  rbc: _all_js__WEBPACK_IMPORTED_MODULE_3__.all,
  rp: _all_js__WEBPACK_IMPORTED_MODULE_3__.all,
  rt: _all_js__WEBPACK_IMPORTED_MODULE_3__.all,
  rtc: _all_js__WEBPACK_IMPORTED_MODULE_3__.all,
  ruby: _all_js__WEBPACK_IMPORTED_MODULE_3__.all,
  slot: _all_js__WEBPACK_IMPORTED_MODULE_3__.all,
  small: _all_js__WEBPACK_IMPORTED_MODULE_3__.all,
  span: _all_js__WEBPACK_IMPORTED_MODULE_3__.all,
  sup: _all_js__WEBPACK_IMPORTED_MODULE_3__.all,
  sub: _all_js__WEBPACK_IMPORTED_MODULE_3__.all,
  tbody: _all_js__WEBPACK_IMPORTED_MODULE_3__.all,
  tfoot: _all_js__WEBPACK_IMPORTED_MODULE_3__.all,
  thead: _all_js__WEBPACK_IMPORTED_MODULE_3__.all,
  time: _all_js__WEBPACK_IMPORTED_MODULE_3__.all,

  address: _util_wrap_children_js__WEBPACK_IMPORTED_MODULE_4__.wrapChildren,
  article: _util_wrap_children_js__WEBPACK_IMPORTED_MODULE_4__.wrapChildren,
  aside: _util_wrap_children_js__WEBPACK_IMPORTED_MODULE_4__.wrapChildren,
  body: _util_wrap_children_js__WEBPACK_IMPORTED_MODULE_4__.wrapChildren,
  center: _util_wrap_children_js__WEBPACK_IMPORTED_MODULE_4__.wrapChildren,
  div: _util_wrap_children_js__WEBPACK_IMPORTED_MODULE_4__.wrapChildren,
  fieldset: _util_wrap_children_js__WEBPACK_IMPORTED_MODULE_4__.wrapChildren,
  figcaption: _util_wrap_children_js__WEBPACK_IMPORTED_MODULE_4__.wrapChildren,
  figure: _util_wrap_children_js__WEBPACK_IMPORTED_MODULE_4__.wrapChildren,
  form: _util_wrap_children_js__WEBPACK_IMPORTED_MODULE_4__.wrapChildren,
  footer: _util_wrap_children_js__WEBPACK_IMPORTED_MODULE_4__.wrapChildren,
  header: _util_wrap_children_js__WEBPACK_IMPORTED_MODULE_4__.wrapChildren,
  hgroup: _util_wrap_children_js__WEBPACK_IMPORTED_MODULE_4__.wrapChildren,
  html: _util_wrap_children_js__WEBPACK_IMPORTED_MODULE_4__.wrapChildren,
  legend: _util_wrap_children_js__WEBPACK_IMPORTED_MODULE_4__.wrapChildren,
  main: _util_wrap_children_js__WEBPACK_IMPORTED_MODULE_4__.wrapChildren,
  multicol: _util_wrap_children_js__WEBPACK_IMPORTED_MODULE_4__.wrapChildren,
  nav: _util_wrap_children_js__WEBPACK_IMPORTED_MODULE_4__.wrapChildren,
  picture: _util_wrap_children_js__WEBPACK_IMPORTED_MODULE_4__.wrapChildren,
  section: _util_wrap_children_js__WEBPACK_IMPORTED_MODULE_4__.wrapChildren,

  a: _a_js__WEBPACK_IMPORTED_MODULE_5__.a,
  audio: _media_js__WEBPACK_IMPORTED_MODULE_6__.media,
  b: _strong_js__WEBPACK_IMPORTED_MODULE_7__.strong,
  base: _base_js__WEBPACK_IMPORTED_MODULE_8__.base,
  blockquote: _blockquote_js__WEBPACK_IMPORTED_MODULE_9__.blockquote,
  br: _br_js__WEBPACK_IMPORTED_MODULE_10__.br,
  code: _inline_code_js__WEBPACK_IMPORTED_MODULE_11__.inlineCode,
  dir: _list_js__WEBPACK_IMPORTED_MODULE_12__.list,
  dl: _dl_js__WEBPACK_IMPORTED_MODULE_13__.dl,
  dt: _li_js__WEBPACK_IMPORTED_MODULE_14__.li,
  dd: _li_js__WEBPACK_IMPORTED_MODULE_14__.li,
  del: _del_js__WEBPACK_IMPORTED_MODULE_15__.del,
  em: _em_js__WEBPACK_IMPORTED_MODULE_16__.em,
  h1: _heading_js__WEBPACK_IMPORTED_MODULE_17__.heading,
  h2: _heading_js__WEBPACK_IMPORTED_MODULE_17__.heading,
  h3: _heading_js__WEBPACK_IMPORTED_MODULE_17__.heading,
  h4: _heading_js__WEBPACK_IMPORTED_MODULE_17__.heading,
  h5: _heading_js__WEBPACK_IMPORTED_MODULE_17__.heading,
  h6: _heading_js__WEBPACK_IMPORTED_MODULE_17__.heading,
  hr: _hr_js__WEBPACK_IMPORTED_MODULE_18__.hr,
  i: _em_js__WEBPACK_IMPORTED_MODULE_16__.em,
  iframe: _iframe_js__WEBPACK_IMPORTED_MODULE_19__.iframe,
  img: _img_js__WEBPACK_IMPORTED_MODULE_20__.img,
  image: _img_js__WEBPACK_IMPORTED_MODULE_20__.img,
  input: _input_js__WEBPACK_IMPORTED_MODULE_21__.input,
  kbd: _inline_code_js__WEBPACK_IMPORTED_MODULE_11__.inlineCode,
  li: _li_js__WEBPACK_IMPORTED_MODULE_14__.li,
  listing: _code_js__WEBPACK_IMPORTED_MODULE_22__.code,
  mark: _em_js__WEBPACK_IMPORTED_MODULE_16__.em,
  ol: _list_js__WEBPACK_IMPORTED_MODULE_12__.list,
  p: _p_js__WEBPACK_IMPORTED_MODULE_23__.p,
  plaintext: _code_js__WEBPACK_IMPORTED_MODULE_22__.code,
  pre: _code_js__WEBPACK_IMPORTED_MODULE_22__.code,
  q: _q_js__WEBPACK_IMPORTED_MODULE_24__.q,
  s: _del_js__WEBPACK_IMPORTED_MODULE_15__.del,
  samp: _inline_code_js__WEBPACK_IMPORTED_MODULE_11__.inlineCode,
  select: _select_js__WEBPACK_IMPORTED_MODULE_25__.select,
  strike: _del_js__WEBPACK_IMPORTED_MODULE_15__.del,
  strong: _strong_js__WEBPACK_IMPORTED_MODULE_7__.strong,
  summary: _p_js__WEBPACK_IMPORTED_MODULE_23__.p,
  table: _table_js__WEBPACK_IMPORTED_MODULE_26__.table,
  td: _table_cell_js__WEBPACK_IMPORTED_MODULE_27__.tableCell,
  textarea: _textarea_js__WEBPACK_IMPORTED_MODULE_28__.textarea,
  th: _table_cell_js__WEBPACK_IMPORTED_MODULE_27__.tableCell,
  tr: _table_row_js__WEBPACK_IMPORTED_MODULE_29__.tableRow,
  tt: _inline_code_js__WEBPACK_IMPORTED_MODULE_11__.inlineCode,
  u: _em_js__WEBPACK_IMPORTED_MODULE_16__.em,
  ul: _list_js__WEBPACK_IMPORTED_MODULE_12__.list,
  var: _inline_code_js__WEBPACK_IMPORTED_MODULE_11__.inlineCode,
  video: _media_js__WEBPACK_IMPORTED_MODULE_6__.media,
  wbr: _wbr_js__WEBPACK_IMPORTED_MODULE_30__.wbr,
  xmp: _code_js__WEBPACK_IMPORTED_MODULE_22__.code
}

function ignore() {}


/***/ }),

/***/ "./node_modules/hast-util-to-mdast/lib/handlers/inline-code.js":
/*!*********************************************************************!*\
  !*** ./node_modules/hast-util-to-mdast/lib/handlers/inline-code.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   inlineCode: () => (/* binding */ inlineCode)
/* harmony export */ });
/* harmony import */ var hast_util_to_text__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! hast-util-to-text */ "./node_modules/hast-util-to-text/lib/index.js");
/* harmony import */ var _util_wrap_text_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/wrap-text.js */ "./node_modules/hast-util-to-mdast/lib/util/wrap-text.js");
/**
 * @typedef {import('../types.js').Handle} Handle
 * @typedef {import('../types.js').Element} Element
 */




/**
 * @type {Handle}
 * @param {Element} node
 */
function inlineCode(h, node) {
  return h(node, 'inlineCode', (0,_util_wrap_text_js__WEBPACK_IMPORTED_MODULE_0__.wrapText)(h, (0,hast_util_to_text__WEBPACK_IMPORTED_MODULE_1__.toText)(node)))
}


/***/ }),

/***/ "./node_modules/hast-util-to-mdast/lib/handlers/input.js":
/*!***************************************************************!*\
  !*** ./node_modules/hast-util-to-mdast/lib/handlers/input.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   input: () => (/* binding */ input)
/* harmony export */ });
/* harmony import */ var hast_util_is_element__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! hast-util-is-element */ "./node_modules/hast-util-to-mdast/node_modules/hast-util-is-element/index.js");
/* harmony import */ var _util_find_selected_options_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../util/find-selected-options.js */ "./node_modules/hast-util-to-mdast/lib/util/find-selected-options.js");
/* harmony import */ var _util_own_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../util/own.js */ "./node_modules/hast-util-to-mdast/lib/util/own.js");
/* harmony import */ var _util_resolve_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../util/resolve.js */ "./node_modules/hast-util-to-mdast/lib/util/resolve.js");
/* harmony import */ var _util_wrap_text_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/wrap-text.js */ "./node_modules/hast-util-to-mdast/lib/util/wrap-text.js");
/**
 * @typedef {import('../types.js').Handle} Handle
 * @typedef {import('../types.js').Element} Element
 * @typedef {import('../types.js').Properties} Properties
 * @typedef {import('../types.js').MdastNode} MdastNode
 */







const datalist = (0,hast_util_is_element__WEBPACK_IMPORTED_MODULE_0__.convertElement)('datalist')

/**
 * @type {Handle}
 * @param {Element} node
 */
// eslint-disable-next-line complexity
function input(h, node) {
  /** @type {Properties} */
  // @ts-expect-error: `props` are defined.
  const props = node.properties
  let value = String(props.value || props.placeholder || '')
  /** @type {Array<MdastNode>} */
  const results = []
  /** @type {Array<string>} */
  const texts = []
  /** @type {Array<[string, string|null]>} */
  let values = []
  let index = -1
  /** @type {string} */
  let list

  if (props.disabled || props.type === 'hidden' || props.type === 'file') {
    return
  }

  if (props.type === 'checkbox' || props.type === 'radio') {
    return h(
      node,
      'text',
      (0,_util_wrap_text_js__WEBPACK_IMPORTED_MODULE_1__.wrapText)(h, h[props.checked ? 'checked' : 'unchecked'])
    )
  }

  if (props.type === 'image') {
    return props.alt || value
      ? h(node, 'image', {
          url: (0,_util_resolve_js__WEBPACK_IMPORTED_MODULE_2__.resolve)(h, String(props.src || '') || null),
          title: (0,_util_wrap_text_js__WEBPACK_IMPORTED_MODULE_1__.wrapText)(h, String(props.title || '')) || null,
          alt: (0,_util_wrap_text_js__WEBPACK_IMPORTED_MODULE_1__.wrapText)(h, String(props.alt || value))
        })
      : []
  }

  if (value) {
    values = [[value, null]]
  } else if (
    // `list` is not supported on these types:
    props.type !== 'password' &&
    props.type !== 'file' &&
    props.type !== 'submit' &&
    props.type !== 'reset' &&
    props.type !== 'button' &&
    props.list
  ) {
    list = String(props.list).toUpperCase()

    if (_util_own_js__WEBPACK_IMPORTED_MODULE_3__.own.call(h.nodeById, list) && datalist(h.nodeById[list])) {
      values = (0,_util_find_selected_options_js__WEBPACK_IMPORTED_MODULE_4__.findSelectedOptions)(h, h.nodeById[list], props)
    }
  }

  if (values.length === 0) {
    return
  }

  // Hide password value.
  if (props.type === 'password') {
    // Passwords don’t support `list`.
    values[0] = ['•'.repeat(values[0][0].length), null]
  }

  if (props.type === 'url' || props.type === 'email') {
    while (++index < values.length) {
      value = (0,_util_resolve_js__WEBPACK_IMPORTED_MODULE_2__.resolve)(h, values[index][0])

      results.push(
        h(
          node,
          'link',
          {
            title: null,
            url: (0,_util_wrap_text_js__WEBPACK_IMPORTED_MODULE_1__.wrapText)(h, props.type === 'email' ? 'mailto:' + value : value)
          },
          [{type: 'text', value: (0,_util_wrap_text_js__WEBPACK_IMPORTED_MODULE_1__.wrapText)(h, values[index][1] || value)}]
        )
      )

      if (index !== values.length - 1) {
        results.push({type: 'text', value: ', '})
      }
    }

    return results
  }

  while (++index < values.length) {
    texts.push(
      values[index][1]
        ? values[index][1] + ' (' + values[index][0] + ')'
        : values[index][0]
    )
  }

  return h(node, 'text', (0,_util_wrap_text_js__WEBPACK_IMPORTED_MODULE_1__.wrapText)(h, texts.join(', ')))
}


/***/ }),

/***/ "./node_modules/hast-util-to-mdast/lib/handlers/li.js":
/*!************************************************************!*\
  !*** ./node_modules/hast-util-to-mdast/lib/handlers/li.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   li: () => (/* binding */ li)
/* harmony export */ });
/* harmony import */ var hast_util_is_element__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! hast-util-is-element */ "./node_modules/hast-util-to-mdast/node_modules/hast-util-is-element/index.js");
/* harmony import */ var _util_wrap_children_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/wrap-children.js */ "./node_modules/hast-util-to-mdast/lib/util/wrap-children.js");
/**
 * @typedef {import('../types.js').Handle} Handle
 * @typedef {import('../types.js').Element} Element
 * @typedef {import('../types.js').ElementChild} ElementChild
 * @typedef {import('../types.js').MdastNode} MdastNode
 */




const p = (0,hast_util_is_element__WEBPACK_IMPORTED_MODULE_0__.convertElement)('p')
const input = (0,hast_util_is_element__WEBPACK_IMPORTED_MODULE_0__.convertElement)('input')

/**
 * @type {Handle}
 * @param {Element} node
 */
function li(h, node) {
  const head = node.children[0]
  /** @type {boolean|null} */
  let checked = null
  /** @type {ElementChild} */
  let checkbox
  /** @type {Element|undefined} */
  let clone

  // Check if this node starts with a checkbox.
  if (p(head)) {
    checkbox = head.children[0]

    if (
      input(checkbox) &&
      checkbox.properties &&
      (checkbox.properties.type === 'checkbox' ||
        checkbox.properties.type === 'radio')
    ) {
      checked = Boolean(checkbox.properties.checked)
      clone = {
        ...node,
        children: [
          {...head, children: head.children.slice(1)},
          ...node.children.slice(1)
        ]
      }
    }
  }

  const content = (0,_util_wrap_children_js__WEBPACK_IMPORTED_MODULE_1__.wrapChildren)(h, clone || node)

  return h(node, 'listItem', {spread: content.length > 1, checked}, content)
}


/***/ }),

/***/ "./node_modules/hast-util-to-mdast/lib/handlers/list.js":
/*!**************************************************************!*\
  !*** ./node_modules/hast-util-to-mdast/lib/handlers/list.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   list: () => (/* binding */ list)
/* harmony export */ });
/* harmony import */ var hast_util_is_element__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! hast-util-is-element */ "./node_modules/hast-util-to-mdast/node_modules/hast-util-is-element/index.js");
/* harmony import */ var hast_util_has_property__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! hast-util-has-property */ "./node_modules/hast-util-to-mdast/node_modules/hast-util-has-property/lib/index.js");
/* harmony import */ var _util_list_items_spread_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../util/list-items-spread.js */ "./node_modules/hast-util-to-mdast/lib/util/list-items-spread.js");
/* harmony import */ var _util_wrap_list_items_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/wrap-list-items.js */ "./node_modules/hast-util-to-mdast/lib/util/wrap-list-items.js");
/**
 * @typedef {import('../types.js').Handle} Handle
 * @typedef {import('../types.js').Element} Element
 */






const ol = (0,hast_util_is_element__WEBPACK_IMPORTED_MODULE_0__.convertElement)('ol')

/**
 * @type {Handle}
 * @param {Element} node
 */
function list(h, node) {
  const ordered = ol(node)
  const children = (0,_util_wrap_list_items_js__WEBPACK_IMPORTED_MODULE_1__.wrapListItems)(h, node)
  /** @type {number|null} */
  let start = null

  if (ordered) {
    start = (0,hast_util_has_property__WEBPACK_IMPORTED_MODULE_2__.hasProperty)(node, 'start')
      ? // @ts-expect-error: `props` exist.
        Number.parseInt(String(node.properties.start), 10)
      : 1
  }

  return h(
    node,
    'list',
    {ordered, start, spread: (0,_util_list_items_spread_js__WEBPACK_IMPORTED_MODULE_3__.listItemsSpread)(children)},
    children
  )
}


/***/ }),

/***/ "./node_modules/hast-util-to-mdast/lib/handlers/media.js":
/*!***************************************************************!*\
  !*** ./node_modules/hast-util-to-mdast/lib/handlers/media.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   media: () => (/* binding */ media)
/* harmony export */ });
/* harmony import */ var hast_util_is_element__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! hast-util-is-element */ "./node_modules/hast-util-to-mdast/node_modules/hast-util-is-element/index.js");
/* harmony import */ var mdast_util_to_string__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! mdast-util-to-string */ "./node_modules/mdast-util-to-string/lib/index.js");
/* harmony import */ var unist_util_visit__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! unist-util-visit */ "./node_modules/unist-util-visit/lib/index.js");
/* harmony import */ var unist_util_visit__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! unist-util-visit */ "./node_modules/unist-util-visit/node_modules/unist-util-visit-parents/lib/index.js");
/* harmony import */ var _all_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../all.js */ "./node_modules/hast-util-to-mdast/lib/all.js");
/* harmony import */ var _util_resolve_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../util/resolve.js */ "./node_modules/hast-util-to-mdast/lib/util/resolve.js");
/* harmony import */ var _util_wrap_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../util/wrap.js */ "./node_modules/hast-util-to-mdast/lib/util/wrap.js");
/**
 * @typedef {import('../types.js').Handle} Handle
 * @typedef {import('../types.js').Element} Element
 * @typedef {import('../types.js').Properties} Properties
 * @typedef {import('../types.js').ElementChild} ElementChild
 */








const source = (0,hast_util_is_element__WEBPACK_IMPORTED_MODULE_0__.convertElement)('source')
const video = (0,hast_util_is_element__WEBPACK_IMPORTED_MODULE_0__.convertElement)('video')

/**
 * @type {Handle}
 * @param {Element} node
 */
function media(h, node) {
  let nodes = (0,_all_js__WEBPACK_IMPORTED_MODULE_1__.all)(h, node)
  /** @type {Properties} */
  // @ts-expect-error: `props` are defined.
  const properties = node.properties
  const poster = video(node) && String(properties.poster || '')
  let src = String(properties.src || '')
  let index = -1
  /** @type {boolean} */
  let linkInFallbackContent = false
  /** @type {ElementChild} */
  let child

  ;(0,unist_util_visit__WEBPACK_IMPORTED_MODULE_2__.visit)({type: 'root', children: nodes}, 'link', findLink)

  // If the content links to something, or if it’s not phrasing…
  if (linkInFallbackContent || (0,_util_wrap_js__WEBPACK_IMPORTED_MODULE_3__.wrapNeeded)(nodes)) {
    return nodes
  }

  // Find the source.
  while (!src && ++index < node.children.length) {
    child = node.children[index]
    if (source(child)) {
      // @ts-expect-error: `props` are defined.
      src = String(child.properties.src || '')
    }
  }

  // If there’s a poster defined on the video, create an image.
  if (poster) {
    nodes = [
      {
        type: 'image',
        title: null,
        url: (0,_util_resolve_js__WEBPACK_IMPORTED_MODULE_4__.resolve)(h, poster),
        alt: (0,mdast_util_to_string__WEBPACK_IMPORTED_MODULE_5__.toString)({children: nodes})
      }
    ]
  }

  // Link to the media resource.
  return {
    type: 'link',
    // @ts-expect-error Types are broken.
    title: node.properties.title || null,
    url: (0,_util_resolve_js__WEBPACK_IMPORTED_MODULE_4__.resolve)(h, src),
    // @ts-expect-error Assume phrasing content.
    children: nodes
  }

  function findLink() {
    linkInFallbackContent = true
    return unist_util_visit__WEBPACK_IMPORTED_MODULE_6__.EXIT
  }
}


/***/ }),

/***/ "./node_modules/hast-util-to-mdast/lib/handlers/p.js":
/*!***********************************************************!*\
  !*** ./node_modules/hast-util-to-mdast/lib/handlers/p.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   p: () => (/* binding */ p)
/* harmony export */ });
/* harmony import */ var _all_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../all.js */ "./node_modules/hast-util-to-mdast/lib/all.js");
/**
 * @typedef {import('../types.js').Handle} Handle
 * @typedef {import('../types.js').Element} Element
 */



/**
 * @type {Handle}
 * @param {Element} node
 */
function p(h, node) {
  const nodes = (0,_all_js__WEBPACK_IMPORTED_MODULE_0__.all)(h, node)

  if (nodes.length > 0) {
    return h(node, 'paragraph', nodes)
  }
}


/***/ }),

/***/ "./node_modules/hast-util-to-mdast/lib/handlers/q.js":
/*!***********************************************************!*\
  !*** ./node_modules/hast-util-to-mdast/lib/handlers/q.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   q: () => (/* binding */ q)
/* harmony export */ });
/* harmony import */ var _all_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../all.js */ "./node_modules/hast-util-to-mdast/lib/all.js");
/**
 * @typedef {import('../types.js').Handle} Handle
 * @typedef {import('../types.js').Element} Element
 * @typedef {import('../types.js').MdastNode} MdastNode
 */



/**
 * @type {Handle}
 * @param {Element} node
 */
function q(h, node) {
  const expected = h.quotes[h.qNesting % h.quotes.length]

  h.qNesting++
  const contents = (0,_all_js__WEBPACK_IMPORTED_MODULE_0__.all)(h, node)
  h.qNesting--

  contents.unshift({type: 'text', value: expected.charAt(0)})

  contents.push({
    type: 'text',
    value: expected.length > 1 ? expected.charAt(1) : expected
  })

  return contents
}


/***/ }),

/***/ "./node_modules/hast-util-to-mdast/lib/handlers/root.js":
/*!**************************************************************!*\
  !*** ./node_modules/hast-util-to-mdast/lib/handlers/root.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   root: () => (/* binding */ root)
/* harmony export */ });
/* harmony import */ var _all_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../all.js */ "./node_modules/hast-util-to-mdast/lib/all.js");
/* harmony import */ var _util_wrap_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/wrap.js */ "./node_modules/hast-util-to-mdast/lib/util/wrap.js");
/**
 * @typedef {import('../types.js').Handle} Handle
 * @typedef {import('../types.js').Root} Root
 */




/**
 * @type {Handle}
 * @param {Root} node
 */
function root(h, node) {
  let children = (0,_all_js__WEBPACK_IMPORTED_MODULE_0__.all)(h, node)

  if (h.document || (0,_util_wrap_js__WEBPACK_IMPORTED_MODULE_1__.wrapNeeded)(children)) {
    children = (0,_util_wrap_js__WEBPACK_IMPORTED_MODULE_1__.wrap)(children)
  }

  return h(node, 'root', children)
}


/***/ }),

/***/ "./node_modules/hast-util-to-mdast/lib/handlers/select.js":
/*!****************************************************************!*\
  !*** ./node_modules/hast-util-to-mdast/lib/handlers/select.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   select: () => (/* binding */ select)
/* harmony export */ });
/* harmony import */ var _util_find_selected_options_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/find-selected-options.js */ "./node_modules/hast-util-to-mdast/lib/util/find-selected-options.js");
/* harmony import */ var _util_wrap_text_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/wrap-text.js */ "./node_modules/hast-util-to-mdast/lib/util/wrap-text.js");
/**
 * @typedef {import('../types.js').Handle} Handle
 * @typedef {import('../types.js').Element} Element
 */




/**
 * @type {Handle}
 * @param {Element} node
 */
function select(h, node) {
  const values = (0,_util_find_selected_options_js__WEBPACK_IMPORTED_MODULE_0__.findSelectedOptions)(h, node)
  let index = -1
  /** @type {Array<string>} */
  const results = []
  /** @type {[string, string|null]} */
  let value

  while (++index < values.length) {
    value = values[index]
    results.push(value[1] ? value[1] + ' (' + value[0] + ')' : value[0])
  }

  if (results.length > 0) {
    return h(node, 'text', (0,_util_wrap_text_js__WEBPACK_IMPORTED_MODULE_1__.wrapText)(h, results.join(', ')))
  }
}


/***/ }),

/***/ "./node_modules/hast-util-to-mdast/lib/handlers/strong.js":
/*!****************************************************************!*\
  !*** ./node_modules/hast-util-to-mdast/lib/handlers/strong.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   strong: () => (/* binding */ strong)
/* harmony export */ });
/* harmony import */ var _all_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../all.js */ "./node_modules/hast-util-to-mdast/lib/all.js");
/**
 * @typedef {import('../types.js').Handle} Handle
 * @typedef {import('../types.js').Element} Element
 */



/**
 * @type {Handle}
 * @param {Element} node
 */
function strong(h, node) {
  return h(node, 'strong', (0,_all_js__WEBPACK_IMPORTED_MODULE_0__.all)(h, node))
}


/***/ }),

/***/ "./node_modules/hast-util-to-mdast/lib/handlers/table-cell.js":
/*!********************************************************************!*\
  !*** ./node_modules/hast-util-to-mdast/lib/handlers/table-cell.js ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   tableCell: () => (/* binding */ tableCell)
/* harmony export */ });
/* harmony import */ var _all_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../all.js */ "./node_modules/hast-util-to-mdast/lib/all.js");
/**
 * @typedef {import('../types.js').Handle} Handle
 * @typedef {import('../types.js').Element} Element
 * @typedef {import('../types.js').MdastNode} MdastNode
 */



/**
 * @type {Handle}
 * @param {Element} node
 */
function tableCell(h, node) {
  const wrap = h.wrapText

  h.wrapText = false

  const result = h(node, 'tableCell', (0,_all_js__WEBPACK_IMPORTED_MODULE_0__.all)(h, node))

  if (node.properties && (node.properties.rowSpan || node.properties.colSpan)) {
    const data = result.data || (result.data = {})
    if (node.properties.rowSpan) data.rowSpan = node.properties.rowSpan
    if (node.properties.colSpan) data.colSpan = node.properties.colSpan
  }

  h.wrapText = wrap

  return result
}


/***/ }),

/***/ "./node_modules/hast-util-to-mdast/lib/handlers/table-row.js":
/*!*******************************************************************!*\
  !*** ./node_modules/hast-util-to-mdast/lib/handlers/table-row.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   tableRow: () => (/* binding */ tableRow)
/* harmony export */ });
/* harmony import */ var _all_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../all.js */ "./node_modules/hast-util-to-mdast/lib/all.js");
/**
 * @typedef {import('../types.js').Handle} Handle
 * @typedef {import('../types.js').Element} Element
 */



/**
 * @type {Handle}
 * @param {Element} node
 */
function tableRow(h, node) {
  return h(node, 'tableRow', (0,_all_js__WEBPACK_IMPORTED_MODULE_0__.all)(h, node))
}


/***/ }),

/***/ "./node_modules/hast-util-to-mdast/lib/handlers/table.js":
/*!***************************************************************!*\
  !*** ./node_modules/hast-util-to-mdast/lib/handlers/table.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   table: () => (/* binding */ table)
/* harmony export */ });
/* harmony import */ var hast_util_is_element__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! hast-util-is-element */ "./node_modules/hast-util-to-mdast/node_modules/hast-util-is-element/index.js");
/* harmony import */ var hast_util_to_text__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! hast-util-to-text */ "./node_modules/hast-util-to-text/lib/index.js");
/* harmony import */ var unist_util_visit__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! unist-util-visit */ "./node_modules/unist-util-visit/lib/index.js");
/* harmony import */ var unist_util_visit__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! unist-util-visit */ "./node_modules/unist-util-visit/node_modules/unist-util-visit-parents/lib/index.js");
/* harmony import */ var _util_wrap_text_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/wrap-text.js */ "./node_modules/hast-util-to-mdast/lib/util/wrap-text.js");
/* harmony import */ var _all_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../all.js */ "./node_modules/hast-util-to-mdast/lib/all.js");
/**
 * @typedef {import('../types.js').Handle} Handle
 * @typedef {import('../types.js').Element} Element
 * @typedef {import('../types.js').MdastNode} MdastNode
 * @typedef {import('../types.js').MdastTableContent} MdastTableContent
 * @typedef {import('../types.js').MdastRowContent} MdastRowContent
 * @typedef {import('../types.js').MdastPhrasingContent} MdastPhrasingContent
 *
 * @typedef Info
 * @property {Array<string|null>} align
 * @property {boolean} headless
 */







const thead = (0,hast_util_is_element__WEBPACK_IMPORTED_MODULE_0__.convertElement)('thead')
const tr = (0,hast_util_is_element__WEBPACK_IMPORTED_MODULE_0__.convertElement)('tr')
const cell = (0,hast_util_is_element__WEBPACK_IMPORTED_MODULE_0__.convertElement)(['th', 'td'])

/**
 * @type {Handle}
 * @param {Element} node
 */
function table(h, node) {
  if (h.inTable) {
    return h(node, 'text', (0,_util_wrap_text_js__WEBPACK_IMPORTED_MODULE_1__.wrapText)(h, (0,hast_util_to_text__WEBPACK_IMPORTED_MODULE_2__.toText)(node)))
  }

  h.inTable = true

  const {headless, align} = inspect(node)
  const rows = toRows((0,_all_js__WEBPACK_IMPORTED_MODULE_3__.all)(h, node), headless)
  let columns = 1
  let rowIndex = -1

  while (++rowIndex < rows.length) {
    const cells = rows[rowIndex].children
    let cellIndex = -1

    while (++cellIndex < cells.length) {
      const cell = cells[cellIndex]

      if (cell.data) {
        const colSpan = Number.parseInt(String(cell.data.colSpan), 10) || 1
        const rowSpan = Number.parseInt(String(cell.data.rowSpan), 10) || 1

        if (colSpan > 1 || rowSpan > 1) {
          let otherRowIndex = rowIndex - 1

          while (++otherRowIndex < rowIndex + rowSpan) {
            let colIndex = cellIndex - 1

            while (++colIndex < cellIndex + colSpan) {
              if (!rows[otherRowIndex]) {
                // Don’t add rows that don’t exist.
                // Browsers don’t render them either.
                break
              }

              /** @type {Array<MdastRowContent>} */
              const newCells = []

              if (otherRowIndex !== rowIndex || colIndex !== cellIndex) {
                newCells.push({type: 'tableCell', children: []})
              }

              rows[otherRowIndex].children.splice(colIndex, 0, ...newCells)
            }
          }
        }

        // Clean the data fields.
        if ('colSpan' in cell.data) delete cell.data.colSpan
        if ('rowSpan' in cell.data) delete cell.data.rowSpan
        if (Object.keys(cell.data).length === 0) delete cell.data
      }
    }

    if (cells.length > columns) columns = cells.length
  }

  // Add extra empty cells.
  rowIndex = -1

  while (++rowIndex < rows.length) {
    const cells = rows[rowIndex].children
    let cellIndex = cells.length - 1
    while (++cellIndex < columns) {
      cells.push({type: 'tableCell', children: []})
    }
  }

  let alignIndex = align.length - 1
  while (++alignIndex < columns) {
    align.push(null)
  }

  h.inTable = false

  return h(node, 'table', {align}, rows)
}

/**
 * Infer whether the HTML table has a head and how it aligns.
 *
 * @param {Element} node
 * @returns {Info}
 */
function inspect(node) {
  let headless = true
  let rowIndex = 0
  let cellIndex = 0
  /** @type {Array<string|null>} */
  const align = [null]

  ;(0,unist_util_visit__WEBPACK_IMPORTED_MODULE_4__.visit)(node, 'element', (child) => {
    if (child.tagName === 'table' && node !== child) {
      return unist_util_visit__WEBPACK_IMPORTED_MODULE_5__.SKIP
    }

    // If there is a `thead`, assume there is a header row.
    if (cell(child) && child.properties) {
      if (!align[cellIndex]) {
        align[cellIndex] = String(child.properties.align || '') || null
      }

      // If there is a th in the first row, assume there is a header row.
      if (headless && rowIndex < 2 && child.tagName === 'th') {
        headless = false
      }

      cellIndex++
    } else if (thead(child)) {
      headless = false
    } else if (tr(child)) {
      rowIndex++
      cellIndex = 0
    }
  })

  return {align, headless}
}

/**
 * Ensure the rows are properly structured.
 *
 * @param {Array<MdastNode>} children
 * @param {boolean} headless
 * @returns {Array<MdastTableContent>}
 */
function toRows(children, headless) {
  let index = -1
  /** @type {Array<MdastTableContent>} */
  const nodes = []
  /** @type {Array<MdastRowContent>|undefined} */
  let queue

  // Add an empty header row.
  if (headless) {
    nodes.push({type: 'tableRow', children: []})
  }

  while (++index < children.length) {
    const node = children[index]

    if (node.type === 'tableRow') {
      if (queue) {
        node.children.unshift(...queue)
        queue = undefined
      }

      nodes.push(node)
    } else {
      if (!queue) queue = []
      // @ts-expect-error Assume row content.
      queue.push(node)
    }
  }

  if (queue) {
    nodes[nodes.length - 1].children.push(...queue)
  }

  index = -1

  while (++index < nodes.length) {
    nodes[index].children = toCells(nodes[index].children)
  }

  return nodes
}

/**
 * Ensure the cells in a row are properly structured.
 *
 * @param {Array<MdastNode>} children
 * @returns {Array<MdastRowContent>}
 */
function toCells(children) {
  /** @type {Array<MdastRowContent>} */
  const nodes = []
  let index = -1
  /** @type {MdastNode} */
  let node
  /** @type {Array<MdastPhrasingContent>|undefined} */
  let queue

  while (++index < children.length) {
    node = children[index]

    if (node.type === 'tableCell') {
      if (queue) {
        node.children.unshift(...queue)
        queue = undefined
      }

      nodes.push(node)
    } else {
      if (!queue) queue = []
      // @ts-expect-error Assume phrasing content.
      queue.push(node)
    }
  }

  if (queue) {
    node = nodes[nodes.length - 1]

    if (!node) {
      node = {type: 'tableCell', children: []}
      nodes.push(node)
    }

    node.children.push(...queue)
  }

  return nodes
}


/***/ }),

/***/ "./node_modules/hast-util-to-mdast/lib/handlers/text.js":
/*!**************************************************************!*\
  !*** ./node_modules/hast-util-to-mdast/lib/handlers/text.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   text: () => (/* binding */ text)
/* harmony export */ });
/* harmony import */ var _util_wrap_text_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/wrap-text.js */ "./node_modules/hast-util-to-mdast/lib/util/wrap-text.js");
/**
 * @typedef {import('../types.js').Handle} Handle
 * @typedef {import('../types.js').Text} Text
 */



/**
 * @type {Handle}
 * @param {Text} node
 */
function text(h, node) {
  return h(node, 'text', (0,_util_wrap_text_js__WEBPACK_IMPORTED_MODULE_0__.wrapText)(h, node.value))
}


/***/ }),

/***/ "./node_modules/hast-util-to-mdast/lib/handlers/textarea.js":
/*!******************************************************************!*\
  !*** ./node_modules/hast-util-to-mdast/lib/handlers/textarea.js ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   textarea: () => (/* binding */ textarea)
/* harmony export */ });
/* harmony import */ var hast_util_to_text__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! hast-util-to-text */ "./node_modules/hast-util-to-text/lib/index.js");
/* harmony import */ var _util_wrap_text_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/wrap-text.js */ "./node_modules/hast-util-to-mdast/lib/util/wrap-text.js");
/**
 * @typedef {import('../types.js').Handle} Handle
 * @typedef {import('../types.js').Element} Element
 */




/**
 * @type {Handle}
 * @param {Element} node
 */
function textarea(h, node) {
  return h(node, 'text', (0,_util_wrap_text_js__WEBPACK_IMPORTED_MODULE_0__.wrapText)(h, (0,hast_util_to_text__WEBPACK_IMPORTED_MODULE_1__.toText)(node)))
}


/***/ }),

/***/ "./node_modules/hast-util-to-mdast/lib/handlers/wbr.js":
/*!*************************************************************!*\
  !*** ./node_modules/hast-util-to-mdast/lib/handlers/wbr.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   wbr: () => (/* binding */ wbr)
/* harmony export */ });
/**
 * @typedef {import('../types.js').Handle} Handle
 * @typedef {import('../types.js').Element} Element
 */

/**
 * @type {Handle}
 * @param {Element} node
 */
function wbr(h, node) {
  return h(node, 'text', '\u200B')
}


/***/ }),

/***/ "./node_modules/hast-util-to-mdast/lib/index.js":
/*!******************************************************!*\
  !*** ./node_modules/hast-util-to-mdast/lib/index.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   all: () => (/* reexport safe */ _all_js__WEBPACK_IMPORTED_MODULE_1__.all),
/* harmony export */   defaultHandlers: () => (/* reexport safe */ _handlers_index_js__WEBPACK_IMPORTED_MODULE_3__.handlers),
/* harmony export */   one: () => (/* reexport safe */ _one_js__WEBPACK_IMPORTED_MODULE_0__.one),
/* harmony export */   toMdast: () => (/* binding */ toMdast)
/* harmony export */ });
/* harmony import */ var rehype_minify_whitespace__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! rehype-minify-whitespace */ "./node_modules/rehype-minify-whitespace/index.js");
/* harmony import */ var unist_util_is__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! unist-util-is */ "./node_modules/hast-util-to-mdast/node_modules/unist-util-is/lib/index.js");
/* harmony import */ var unist_util_visit__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! unist-util-visit */ "./node_modules/unist-util-visit/lib/index.js");
/* harmony import */ var _one_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./one.js */ "./node_modules/hast-util-to-mdast/lib/one.js");
/* harmony import */ var _handlers_index_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./handlers/index.js */ "./node_modules/hast-util-to-mdast/lib/handlers/index.js");
/* harmony import */ var _util_own_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./util/own.js */ "./node_modules/hast-util-to-mdast/lib/util/own.js");
/* harmony import */ var _all_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./all.js */ "./node_modules/hast-util-to-mdast/lib/all.js");
/**
 * @typedef {import('./types.js').Node} Node
 * @typedef {import('./types.js').Element} Element
 * @typedef {import('./types.js').Options} Options
 * @typedef {import('./types.js').Properties} Properties
 * @typedef {import('./types.js').H} H
 * @typedef {import('./types.js').HWithoutProps} HWithoutProps
 * @typedef {import('./types.js').HWithProps} HWithProps
 * @typedef {import('./types.js').MdastNode} MdastNode
 * @typedef {import('./types.js').MdastRoot} MdastRoot
 */











const block = (0,unist_util_is__WEBPACK_IMPORTED_MODULE_2__.convert)(['heading', 'paragraph', 'root'])

/**
 * Transform hast to mdast.
 *
 * @param {Node} tree
 *   Tree (hast).
 * @param {Options} [options]
 *   Configuration (optional).
 */
function toMdast(tree, options = {}) {
  /** @type {Record<string, Element>} */
  const byId = {}
  /** @type {MdastNode|MdastRoot} */
  let mdast

  /**
   * @type {H}
   */
  const h = Object.assign(
    /**
     * @type {HWithProps & HWithoutProps}
     */
    (
      /**
       * @param {Node} node
       * @param {string} type
       * @param {Properties|string|Array<Node>} [props]
       * @param {string|Array<Node>} [children]
       */
      (node, type, props, children) => {
        /** @type {Properties|undefined} */
        let properties

        if (typeof props === 'string' || Array.isArray(props)) {
          children = props
          properties = {}
        } else {
          properties = props
        }

        /** @type {Node} */
        // @ts-expect-error Assume valid `type` and `children`/`value`.
        const result = {type, ...properties}

        if (typeof children === 'string') {
          // @ts-expect-error: Looks like a literal.
          result.value = children
        } else if (children) {
          // @ts-expect-error: Looks like a parent.
          result.children = children
        }

        if (node.position) {
          result.position = node.position
        }

        return result
      }
    ),
    {
      nodeById: byId,
      baseFound: false,
      inTable: false,
      wrapText: true,
      /** @type {string|null} */
      frozenBaseUrl: null,
      qNesting: 0,
      handlers: options.handlers
        ? {..._handlers_index_js__WEBPACK_IMPORTED_MODULE_3__.handlers, ...options.handlers}
        : _handlers_index_js__WEBPACK_IMPORTED_MODULE_3__.handlers,
      document: options.document,
      checked: options.checked || '[x]',
      unchecked: options.unchecked || '[ ]',
      quotes: options.quotes || ['"']
    }
  )

  ;(0,unist_util_visit__WEBPACK_IMPORTED_MODULE_4__.visit)(tree, 'element', (node) => {
    const id =
      node.properties &&
      'id' in node.properties &&
      String(node.properties.id).toUpperCase()

    if (id && !_util_own_js__WEBPACK_IMPORTED_MODULE_5__.own.call(byId, id)) {
      byId[id] = node
    }
  })

  // @ts-expect-error: does return a transformer, that does accept any node.
  ;(0,rehype_minify_whitespace__WEBPACK_IMPORTED_MODULE_6__["default"])({newlines: options.newlines === true})(tree)

  const result = (0,_one_js__WEBPACK_IMPORTED_MODULE_0__.one)(h, tree, undefined)

  if (!result) {
    mdast = {type: 'root', children: []}
  } else if (Array.isArray(result)) {
    mdast = {type: 'root', children: result}
  } else {
    mdast = result
  }

  (0,unist_util_visit__WEBPACK_IMPORTED_MODULE_4__.visit)(mdast, 'text', ontext)

  return mdast

  /**
   * Collapse text nodes, and fix whitespace.
   * Most of this is taken care of by `rehype-minify-whitespace`, but
   * we’re generating some whitespace too, and some nodes are in the end
   * ignored.
   * So clean up.
   *
   * @type {import('unist-util-visit/complex-types').BuildVisitor<MdastRoot, 'text'>}
   */
  function ontext(node, index, parent) {
    /* c8 ignore next 3 */
    if (index === null || !parent) {
      return
    }

    const previous = parent.children[index - 1]

    if (previous && previous.type === node.type) {
      previous.value += node.value
      parent.children.splice(index, 1)

      if (previous.position && node.position) {
        previous.position.end = node.position.end
      }

      // Iterate over the previous node again, to handle its total value.
      return index - 1
    }

    node.value = node.value.replace(/[\t ]*(\r?\n|\r)[\t ]*/, '$1')

    // We don’t care about other phrasing nodes in between (e.g., `[ asd ]()`),
    // as there the whitespace matters.
    if (parent && block(parent)) {
      if (!index) {
        node.value = node.value.replace(/^[\t ]+/, '')
      }

      if (index === parent.children.length - 1) {
        node.value = node.value.replace(/[\t ]+$/, '')
      }
    }

    if (!node.value) {
      parent.children.splice(index, 1)
      return index
    }
  }
}




/***/ }),

/***/ "./node_modules/hast-util-to-mdast/lib/one.js":
/*!****************************************************!*\
  !*** ./node_modules/hast-util-to-mdast/lib/one.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   one: () => (/* binding */ one)
/* harmony export */ });
/* harmony import */ var _all_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./all.js */ "./node_modules/hast-util-to-mdast/lib/all.js");
/* harmony import */ var _util_own_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./util/own.js */ "./node_modules/hast-util-to-mdast/lib/util/own.js");
/* harmony import */ var _util_wrap_text_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./util/wrap-text.js */ "./node_modules/hast-util-to-mdast/lib/util/wrap-text.js");
/**
 * @typedef {import('./types.js').H} H
 * @typedef {import('./types.js').Node} Node
 * @typedef {import('./types.js').Parent} Parent
 * @typedef {import('./types.js').Handle} Handle
 * @typedef {import('./types.js').MdastNode} MdastNode
 */





/**
 * @param {H} h
 * @param {Node} node
 * @param {Parent|undefined} parent
 * @returns {MdastNode|Array<MdastNode>|void}
 */
function one(h, node, parent) {
  /** @type {Handle|undefined} */
  let fn

  if (node.type === 'element') {
    if (node.properties && node.properties.dataMdast === 'ignore') {
      return
    }

    if (_util_own_js__WEBPACK_IMPORTED_MODULE_0__.own.call(h.handlers, node.tagName)) {
      fn = h.handlers[node.tagName]
    }
  } else if (_util_own_js__WEBPACK_IMPORTED_MODULE_0__.own.call(h.handlers, node.type)) {
    fn = h.handlers[node.type]
  }

  if (typeof fn === 'function') {
    return fn(h, node, parent)
  }

  return unknown(h, node)
}

/**
 * @type {Handle}
 * @param {Node} node
 */
function unknown(h, node) {
  // @ts-expect-error: Looks like a literal.
  if (typeof node.value === 'string') {
    // @ts-expect-error: Looks like a literal.
    return h(node, 'text', (0,_util_wrap_text_js__WEBPACK_IMPORTED_MODULE_1__.wrapText)(h, node.value))
  }

  return (0,_all_js__WEBPACK_IMPORTED_MODULE_2__.all)(h, node)
}


/***/ }),

/***/ "./node_modules/hast-util-to-mdast/lib/util/find-selected-options.js":
/*!***************************************************************************!*\
  !*** ./node_modules/hast-util-to-mdast/lib/util/find-selected-options.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   findSelectedOptions: () => (/* binding */ findSelectedOptions)
/* harmony export */ });
/* harmony import */ var hast_util_has_property__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! hast-util-has-property */ "./node_modules/hast-util-to-mdast/node_modules/hast-util-has-property/lib/index.js");
/* harmony import */ var hast_util_is_element__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! hast-util-is-element */ "./node_modules/hast-util-to-mdast/node_modules/hast-util-is-element/index.js");
/* harmony import */ var hast_util_to_text__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! hast-util-to-text */ "./node_modules/hast-util-to-text/lib/index.js");
/* harmony import */ var _wrap_text_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./wrap-text.js */ "./node_modules/hast-util-to-mdast/lib/util/wrap-text.js");
/**
 * @typedef {import('../types.js').H} H
 * @typedef {import('../types.js').Parent} Parent
 * @typedef {import('../types.js').Element} Element
 * @typedef {import('../types.js').Child} Child
 * @typedef {import('../types.js').Properties} Properties
 */






const option = (0,hast_util_is_element__WEBPACK_IMPORTED_MODULE_0__.convertElement)('option')

/**
 * @param {H} h
 * @param {Element} node
 * @param {Properties} [properties]
 * @returns {Array<[string, string|null]>}
 */
function findSelectedOptions(h, node, properties) {
  /** @type {Properties} */
  // @ts-expect-error: `props` exist.
  const props = properties || node.properties
  let options = findOptions(node)
  const size =
    Math.min(Number.parseInt(String(props.size), 10), 0) ||
    (props.multiple ? 4 : 1)
  let index = -1
  /** @type {Array<Element>} */
  const selectedOptions = []
  /** @type {Array<[string, string|null]>} */
  const values = []

  while (++index < options.length) {
    if ((0,hast_util_has_property__WEBPACK_IMPORTED_MODULE_1__.hasProperty)(options[index], 'selected')) {
      selectedOptions.push(options[index])
    }
  }

  const list = selectedOptions.length > 0 ? selectedOptions : options
  options = list.slice(0, size)
  index = -1

  while (++index < options.length) {
    const option = options[index]
    const content = (0,_wrap_text_js__WEBPACK_IMPORTED_MODULE_2__.wrapText)(h, (0,hast_util_to_text__WEBPACK_IMPORTED_MODULE_3__.toText)(option))
    /** @type {Properties} */
    // @ts-expect-error: `props` exist.
    const props = option.properties
    const label = content || String(props.label || '')
    const value = String(props.value || '') || content
    values.push([value, label === value ? null : label])
  }

  return values
}

/**
 * @param {Parent} node
 */
function findOptions(node) {
  const children = node.children
  let index = -1
  /** @type {Array<Element>} */
  let results = []
  /** @type {Child} */
  let child

  while (++index < children.length) {
    child = children[index]

    // @ts-expect-error Looks like a parent.
    if (Array.isArray(child.children)) {
      // @ts-expect-error Looks like a parent.
      results = results.concat(findOptions(child))
    }

    if (option(child) && !(0,hast_util_has_property__WEBPACK_IMPORTED_MODULE_1__.hasProperty)(child, 'disabled')) {
      results.push(child)
    }
  }

  return results
}


/***/ }),

/***/ "./node_modules/hast-util-to-mdast/lib/util/list-items-spread.js":
/*!***********************************************************************!*\
  !*** ./node_modules/hast-util-to-mdast/lib/util/list-items-spread.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   listItemsSpread: () => (/* binding */ listItemsSpread)
/* harmony export */ });
/**
 * @typedef {import('../types.js').MdastListContent} MdastListContent
 */

/**
 * @param {Array<MdastListContent>} children
 * @returns {boolean}
 */
function listItemsSpread(children) {
  let index = -1

  if (children.length > 1) {
    while (++index < children.length) {
      if (children[index].spread) {
        return true
      }
    }
  }

  return false
}


/***/ }),

/***/ "./node_modules/hast-util-to-mdast/lib/util/own.js":
/*!*********************************************************!*\
  !*** ./node_modules/hast-util-to-mdast/lib/util/own.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   own: () => (/* binding */ own)
/* harmony export */ });
const own = {}.hasOwnProperty


/***/ }),

/***/ "./node_modules/hast-util-to-mdast/lib/util/resolve.js":
/*!*************************************************************!*\
  !*** ./node_modules/hast-util-to-mdast/lib/util/resolve.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   resolve: () => (/* binding */ resolve)
/* harmony export */ });
/**
 * @typedef {import('../types.js').H} H
 */

/**
 * @param {H} h
 * @param {string|null|undefined} url
 * @returns {string}
 */
function resolve(h, url) {
  if (url === null || url === undefined) {
    return ''
  }

  if (h.frozenBaseUrl) {
    return String(new URL(url, h.frozenBaseUrl))
  }

  return url
}


/***/ }),

/***/ "./node_modules/hast-util-to-mdast/lib/util/wrap-children.js":
/*!*******************************************************************!*\
  !*** ./node_modules/hast-util-to-mdast/lib/util/wrap-children.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   wrapChildren: () => (/* binding */ wrapChildren)
/* harmony export */ });
/* harmony import */ var _all_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../all.js */ "./node_modules/hast-util-to-mdast/lib/all.js");
/* harmony import */ var _wrap_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./wrap.js */ "./node_modules/hast-util-to-mdast/lib/util/wrap.js");
/**
 * @typedef {import('../types.js').H} H
 * @typedef {import('../types.js').Node} Node
 * @typedef {import('../types.js').MdastNode} MdastNode
 */




/**
 * @param {H} h
 * @param {Node} node
 * @returns {Array<MdastNode>}
 */
function wrapChildren(h, node) {
  return (0,_wrap_js__WEBPACK_IMPORTED_MODULE_0__.wrap)((0,_all_js__WEBPACK_IMPORTED_MODULE_1__.all)(h, node))
}


/***/ }),

/***/ "./node_modules/hast-util-to-mdast/lib/util/wrap-list-items.js":
/*!*********************************************************************!*\
  !*** ./node_modules/hast-util-to-mdast/lib/util/wrap-list-items.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   wrapListItems: () => (/* binding */ wrapListItems)
/* harmony export */ });
/* harmony import */ var _all_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../all.js */ "./node_modules/hast-util-to-mdast/lib/all.js");
/**
 * @typedef {import('../types.js').H} H
 * @typedef {import('../types.js').Child} Child
 * @typedef {import('../types.js').MdastListContent} MdastListContent
 */



/**
 * @param {H} h
 * @param {Child} node
 * @returns {Array<MdastListContent>}
 */
function wrapListItems(h, node) {
  const children = (0,_all_js__WEBPACK_IMPORTED_MODULE_0__.all)(h, node)
  let index = -1

  while (++index < children.length) {
    const child = children[index]
    if (child.type !== 'listItem') {
      children[index] = {
        type: 'listItem',
        spread: false,
        checked: null,
        // @ts-expect-error Assume `children[index]` is block content.
        children: [child]
      }
    }
  }

  // @ts-expect-error Assume all `listItem`s
  return children
}


/***/ }),

/***/ "./node_modules/hast-util-to-mdast/lib/util/wrap-text.js":
/*!***************************************************************!*\
  !*** ./node_modules/hast-util-to-mdast/lib/util/wrap-text.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   wrapText: () => (/* binding */ wrapText)
/* harmony export */ });
/**
 * @typedef {import('../types.js').H} H
 */

/**
 * @param {H} h
 * @param {string} value
 * @returns {string}
 */
function wrapText(h, value) {
  return h.wrapText ? value : value.replace(/\r?\n|\r/g, ' ')
}


/***/ }),

/***/ "./node_modules/hast-util-to-mdast/lib/util/wrap.js":
/*!**********************************************************!*\
  !*** ./node_modules/hast-util-to-mdast/lib/util/wrap.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   wrap: () => (/* binding */ wrap),
/* harmony export */   wrapNeeded: () => (/* binding */ wrapNeeded)
/* harmony export */ });
/* harmony import */ var extend__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! extend */ "./node_modules/extend/index.js");
/* harmony import */ var hast_util_phrasing__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! hast-util-phrasing */ "./node_modules/hast-util-to-mdast/node_modules/hast-util-phrasing/lib/index.js");
/* harmony import */ var mdast_util_phrasing__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! mdast-util-phrasing */ "./node_modules/mdast-util-phrasing/lib/index.js");
/**
 * @typedef {import('../types.js').MdastNode} MdastNode
 * @typedef {import('../types.js').MdastPhrasingContent} MdastPhrasingContent
 */





/**
 * @param {Array<MdastNode>} nodes
 */
function wrap(nodes) {
  return runs(nodes, onphrasing)

  /**
   * @param {Array<MdastPhrasingContent>} nodes
   * @returns {MdastNode|Array<MdastNode>}
   */
  function onphrasing(nodes) {
    const head = nodes[0]

    if (
      nodes.length === 1 &&
      head.type === 'text' &&
      (head.value === ' ' || head.value === '\n')
    ) {
      return []
    }

    return {type: 'paragraph', children: nodes}
  }
}

/**
 * Check if there are non-phrasing mdast nodes returned.
 * This is needed if a fragment is given, which could just be a sentence, and
 * doesn’t need a wrapper paragraph.
 *
 * @param {Array<MdastNode>} nodes
 * @returns {boolean}
 */
function wrapNeeded(nodes) {
  let index = -1
  /** @type {MdastNode} */
  let node

  while (++index < nodes.length) {
    node = nodes[index]

    if (!phrasing(node) || ('children' in node && wrapNeeded(node.children))) {
      return true
    }
  }

  return false
}

/**
 * Wrap all runs of mdast phrasing content in `paragraph` nodes.
 *
 * @param {Array<MdastNode>} nodes
 * @param {(nodes: Array<MdastPhrasingContent>) => MdastNode|Array<MdastNode>} onphrasing
 * @param {(node: MdastNode) => MdastNode} [onnonphrasing]
 */
function runs(nodes, onphrasing, onnonphrasing) {
  const nonphrasing = onnonphrasing || identity
  /** @type {Array<MdastNode>} */
  const flattened = flatten(nodes)
  /** @type {Array<MdastNode>} */
  let result = []
  let index = -1
  /** @type {Array<MdastPhrasingContent>|undefined} */
  let queue
  /** @type {MdastNode} */
  let node

  while (++index < flattened.length) {
    node = flattened[index]

    if (phrasing(node)) {
      if (!queue) queue = []
      queue.push(node)
    } else {
      if (queue) {
        result = result.concat(onphrasing(queue))
        queue = undefined
      }

      result = result.concat(nonphrasing(node))
    }
  }

  if (queue) {
    result = result.concat(onphrasing(queue))
  }

  return result
}

/**
 * Flatten a list of nodes.
 *
 * @param {Array<MdastNode>} nodes
 * @returns {Array<MdastNode>}
 */
function flatten(nodes) {
  /** @type {Array<MdastNode>} */
  let flattened = []
  let index = -1
  /** @type {MdastNode} */
  let node

  while (++index < nodes.length) {
    node = nodes[index]

    // Straddling: some elements are *weird*.
    // Namely: `map`, `ins`, `del`, and `a`, as they are hybrid elements.
    // See: <https://html.spec.whatwg.org/#paragraphs>.
    // Paragraphs are the weirdest of them all.
    // See the straddling fixture for more info!
    // `ins` is ignored in mdast, so we don’t need to worry about that.
    // `map` maps to its content, so we don’t need to worry about that either.
    // `del` maps to `delete` and `a` to `link`, so we do handle those.
    // What we’ll do is split `node` over each of its children.
    if (
      (node.type === 'delete' || node.type === 'link') &&
      wrapNeeded(node.children)
    ) {
      flattened = flattened.concat(split(node))
    } else {
      flattened.push(node)
    }
  }

  return flattened
}

/**
 * @param {MdastNode} node
 * @returns {Array<MdastNode>}
 */
function split(node) {
  // @ts-expect-error Assume parent.
  return runs(node.children, onphrasing, onnonphrasing)

  /**
   * Use `child`, add `parent` as its first child, put the original children
   * into `parent`.
   * If `child` is not a parent, `parent` will not be added.
   *
   * @param {MdastNode} child
   * @returns {MdastNode}
   */
  function onnonphrasing(child) {
    if ('children' in child && 'children' in node) {
      const {children, ...rest} = node
      return {
        ...child,
        // @ts-expect-error: assume matching parent & child.
        children: [{...extend__WEBPACK_IMPORTED_MODULE_0__(true, {}, rest), children: child.children}]
      }
    }

    return {...child}
  }

  /**
   * Use `parent`, put the phrasing run inside it.
   *
   * @param {Array<MdastPhrasingContent>} nodes
   * @returns {MdastNode}
   */
  function onphrasing(nodes) {
    // @ts-expect-error: assume parent.
    const {children, ...rest} = node
    // @ts-expect-error: assume matching parent & child.
    return {...extend__WEBPACK_IMPORTED_MODULE_0__(true, {}, rest), children: nodes}
  }
}

/**
 * Check if an mdast node is phrasing.
 *
 * Also supports checking embedded hast fields.
 *
 * @param {MdastNode} node
 * @returns {node is MdastPhrasingContent}
 */
function phrasing(node) {
  return node.data && node.data.hName
    ? (0,hast_util_phrasing__WEBPACK_IMPORTED_MODULE_1__.phrasing)({
        type: 'element',
        tagName: node.data.hName,
        properties: {},
        children: []
      })
    : (0,mdast_util_phrasing__WEBPACK_IMPORTED_MODULE_2__.phrasing)(node)
}

/**
 * @template {unknown} T
 * @param {T} n
 * @returns {T}
 */
function identity(n) {
  return n
}


/***/ }),

/***/ "./node_modules/hast-util-to-mdast/node_modules/hast-util-embedded/lib/index.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/hast-util-to-mdast/node_modules/hast-util-embedded/lib/index.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   embedded: () => (/* binding */ embedded)
/* harmony export */ });
/* harmony import */ var hast_util_is_element__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! hast-util-is-element */ "./node_modules/hast-util-to-mdast/node_modules/hast-util-is-element/index.js");
/**
 * @typedef {import('hast').Element} Element
 */



/**
 * Check if a node is a *embedded content*.
 *
 * @type {import('hast-util-is-element').AssertPredicate<Element & {tagName: 'audio' | 'canvas' | 'embed' | 'iframe' | 'img' | 'math' | 'object' | 'picture' | 'svg' | 'video'}>}
 * @param value
 *   Thing to check (typically `Node`).
 * @returns
 *   Whether `value` is an element considered embedded content.
 *
 *   The elements `audio`, `canvas`, `embed`, `iframe`, `img`, `math`,
 *   `object`, `picture`, `svg`, and `video` are embedded content.
 */
// @ts-expect-error Sure, the assertion matches.
const embedded = (0,hast_util_is_element__WEBPACK_IMPORTED_MODULE_0__.convertElement)([
  'audio',
  'canvas',
  'embed',
  'iframe',
  'img',
  'math',
  'object',
  'picture',
  'svg',
  'video'
])


/***/ }),

/***/ "./node_modules/hast-util-to-mdast/node_modules/hast-util-has-property/lib/index.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/hast-util-to-mdast/node_modules/hast-util-has-property/lib/index.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   hasProperty: () => (/* binding */ hasProperty)
/* harmony export */ });
/**
 * @typedef {import('hast').Root} Root
 * @typedef {import('hast').Content} Content
 */

/**
 * @typedef {Root | Content} Node
 */

const own = {}.hasOwnProperty

/**
 * Check if `node`is an element and has a `field` property.
 *
 * @param {unknown} node
 *   Thing to check (typically `Element`).
 * @param {unknown} field
 *   Field name to check (typically `string`).
 * @returns {boolean}
 *   Whether `node` is an element that has a `field` property.
 */
function hasProperty(node, field) {
  const value =
    typeof field === 'string' &&
    isNode(node) &&
    node.type === 'element' &&
    node.properties &&
    own.call(node.properties, field) &&
    node.properties[field]

  return value !== null && value !== undefined && value !== false
}

/**
 * @param {unknown} value
 * @returns {value is Node}
 */
function isNode(value) {
  return Boolean(value && typeof value === 'object' && 'type' in value)
}


/***/ }),

/***/ "./node_modules/hast-util-to-mdast/node_modules/hast-util-is-body-ok-link/index.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/hast-util-to-mdast/node_modules/hast-util-is-body-ok-link/index.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   isBodyOkLink: () => (/* binding */ isBodyOkLink)
/* harmony export */ });
/* harmony import */ var hast_util_is_element__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! hast-util-is-element */ "./node_modules/hast-util-to-mdast/node_modules/hast-util-is-element/index.js");
/* harmony import */ var hast_util_has_property__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! hast-util-has-property */ "./node_modules/hast-util-to-mdast/node_modules/hast-util-has-property/lib/index.js");
/**
 * @fileoverview
 *   Check if a `link` element is “Body OK”.
 * @longdescription
 *   ## Use
 *
 *   ```js
 *   import {h} from 'hastscript'
 *   import {isBodyOkLink} from 'hast-util-is-body-ok-link'
 *
 *   isBodyOkLink(h('link', {itemProp: 'foo'})) //=> true
 *   isBodyOkLink(h('link', {rel: ['stylesheet'], href: 'index.css'})) //=> true
 *   isBodyOkLink(h('link', {rel: ['author'], href: 'index.css'})) //=> false
 *   ```
 *
 *   ## API
 *
 *   ### `isBodyOkLink(node)`
 *
 *   * Return `true` for `link` elements with an `itemProp`
 *   * Return `true` for `link` elements with a `rel` list where one or more
 *     entries are `pingback`, `prefetch`, or `stylesheet`.
 */




const list = new Set(['pingback', 'prefetch', 'stylesheet'])

/**
 * @typedef {import('hast').Root} Root
 * @typedef {Root|Root['children'][number]} Node
 */

/**
 * Check if a `link` element is “Body OK”.
 *
 * @param {Node} node
 * @returns {boolean}
 */
function isBodyOkLink(node) {
  if (!(0,hast_util_is_element__WEBPACK_IMPORTED_MODULE_0__.isElement)(node, 'link')) {
    return false
  }

  if ((0,hast_util_has_property__WEBPACK_IMPORTED_MODULE_1__.hasProperty)(node, 'itemProp')) {
    return true
  }

  const props = node.properties || {}
  const rel = props.rel || []
  let index = -1

  if (!Array.isArray(rel) || rel.length === 0) {
    return false
  }

  while (++index < rel.length) {
    if (!list.has(String(rel[index]))) {
      return false
    }
  }

  return true
}


/***/ }),

/***/ "./node_modules/hast-util-to-mdast/node_modules/hast-util-is-element/index.js":
/*!************************************************************************************!*\
  !*** ./node_modules/hast-util-to-mdast/node_modules/hast-util-is-element/index.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   convertElement: () => (/* binding */ convertElement),
/* harmony export */   isElement: () => (/* binding */ isElement)
/* harmony export */ });
/**
 * @typedef {import('unist').Parent} Parent
 * @typedef {import('hast').Element} Element
 */

/**
 * @typedef {null | undefined | string | TestFunctionAnything | Array<string | TestFunctionAnything>} Test
 *   Check for an arbitrary element, unaware of TypeScript inferral.
 *
 * @callback TestFunctionAnything
 *   Check if an element passes a test, unaware of TypeScript inferral.
 * @param {Element} element
 *   An element.
 * @param {number | null | undefined} [index]
 *   The element’s position in its parent.
 * @param {Parent | null | undefined} [parent]
 *   The element’s parent.
 * @returns {boolean | void}
 *   Whether this element passes the test.
 */

/**
 * @template {Element} T
 *   Element type.
 * @typedef {T['tagName'] | TestFunctionPredicate<T> | Array<T['tagName'] | TestFunctionPredicate<T>>} PredicateTest
 *   Check for an element that can be inferred by TypeScript.
 */

/**
 * Check if an element passes a certain node test.
 *
 * @template {Element} T
 *   Element type.
 * @callback TestFunctionPredicate
 *   Complex test function for an element that can be inferred by TypeScript.
 * @param {Element} element
 *   An element.
 * @param {number | null | undefined} [index]
 *   The element’s position in its parent.
 * @param {Parent | null | undefined} [parent]
 *   The element’s parent.
 * @returns {element is T}
 *   Whether this element passes the test.
 */

/**
 * @callback AssertAnything
 *   Check that an arbitrary value is an element, unaware of TypeScript inferral.
 * @param {unknown} [node]
 *   Anything (typically a node).
 * @param {number | null | undefined} [index]
 *   The node’s position in its parent.
 * @param {Parent | null | undefined} [parent]
 *   The node’s parent.
 * @returns {boolean}
 *   Whether this is an element and passes a test.
 */

/**
 * Check if a node is an element and passes a certain node test
 *
 * @template {Element} T
 *   Element type.
 * @callback AssertPredicate
 *   Check that an arbitrary value is a specific element, aware of TypeScript.
 * @param {unknown} [node]
 *   Anything (typically a node).
 * @param {number | null | undefined} [index]
 *   The node’s position in its parent.
 * @param {Parent | null | undefined} [parent]
 *   The node’s parent.
 * @returns {node is T}
 *   Whether this is an element and passes a test.
 */

/**
 * Check if `node` is an `Element` and whether it passes the given test.
 *
 * @param node
 *   Thing to check, typically `Node`.
 * @param test
 *   A check for a specific element.
 * @param index
 *   The node’s position in its parent.
 * @param parent
 *   The node’s parent.
 * @returns
 *   Whether `node` is an element and passes a test.
 */
const isElement =
  /**
   * @type {(
   *   (() => false) &
   *   (<T extends Element = Element>(node: unknown, test?: PredicateTest<T>, index?: number, parent?: Parent, context?: unknown) => node is T) &
   *   ((node: unknown, test: Test, index?: number, parent?: Parent, context?: unknown) => boolean)
   * )}
   */
  (
    /**
     * @param {unknown} [node]
     * @param {Test | undefined} [test]
     * @param {number | null | undefined} [index]
     * @param {Parent | null | undefined} [parent]
     * @param {unknown} [context]
     * @returns {boolean}
     */
    // eslint-disable-next-line max-params
    function (node, test, index, parent, context) {
      const check = convertElement(test)

      if (
        index !== undefined &&
        index !== null &&
        (typeof index !== 'number' ||
          index < 0 ||
          index === Number.POSITIVE_INFINITY)
      ) {
        throw new Error('Expected positive finite index for child node')
      }

      if (
        parent !== undefined &&
        parent !== null &&
        (!parent.type || !parent.children)
      ) {
        throw new Error('Expected parent node')
      }

      // @ts-expect-error Looks like a node.
      if (!node || !node.type || typeof node.type !== 'string') {
        return false
      }

      if (
        (parent === undefined || parent === null) !==
        (index === undefined || index === null)
      ) {
        throw new Error('Expected both parent and index')
      }

      return check.call(context, node, index, parent)
    }
  )

/**
 * Generate an assertion from a test.
 *
 * Useful if you’re going to test many nodes, for example when creating a
 * utility where something else passes a compatible test.
 *
 * The created function is a bit faster because it expects valid input only:
 * a `node`, `index`, and `parent`.
 *
 * @param test
 *   *  When nullish, checks if `node` is an `Element`.
 *   *  When `string`, works like passing `(element) => element.tagName === test`.
 *   *  When `function` checks if function passed the element is true.
 *   *  When `array`, checks any one of the subtests pass.
 * @returns
 *   An assertion.
 */
const convertElement =
  /**
   * @type {(
   *   (<T extends Element>(test: T['tagName'] | TestFunctionPredicate<T>) => AssertPredicate<T>) &
   *   ((test?: Test) => AssertAnything)
   * )}
   */
  (
    /**
     * @param {Test | null | undefined} [test]
     * @returns {AssertAnything}
     */
    function (test) {
      if (test === undefined || test === null) {
        return element
      }

      if (typeof test === 'string') {
        return tagNameFactory(test)
      }

      if (typeof test === 'object') {
        return anyFactory(test)
      }

      if (typeof test === 'function') {
        return castFactory(test)
      }

      throw new Error('Expected function, string, or array as test')
    }
  )

/**
 * Handle multiple tests.
 *
 * @param {Array<string | TestFunctionAnything>} tests
 * @returns {AssertAnything}
 */
function anyFactory(tests) {
  /** @type {Array<AssertAnything>} */
  const checks = []
  let index = -1

  while (++index < tests.length) {
    checks[index] = convertElement(tests[index])
  }

  return castFactory(any)

  /**
   * @this {unknown}
   * @param {Array<unknown>} parameters
   * @returns {boolean}
   */
  function any(...parameters) {
    let index = -1

    while (++index < checks.length) {
      if (checks[index].call(this, ...parameters)) {
        return true
      }
    }

    return false
  }
}

/**
 * Turn a string into a test for an element with a certain tag name.
 *
 * @param {string} check
 * @returns {AssertAnything}
 */
function tagNameFactory(check) {
  return tagName

  /**
   * @param {unknown} node
   * @returns {boolean}
   */
  function tagName(node) {
    return element(node) && node.tagName === check
  }
}

/**
 * Turn a custom test into a test for an element that passes that test.
 *
 * @param {TestFunctionAnything} check
 * @returns {AssertAnything}
 */
function castFactory(check) {
  return assertion

  /**
   * @this {unknown}
   * @param {unknown} node
   * @param {Array<unknown>} parameters
   * @returns {boolean}
   */
  function assertion(node, ...parameters) {
    // @ts-expect-error: fine.
    return element(node) && Boolean(check.call(this, node, ...parameters))
  }
}

/**
 * Make sure something is an element.
 *
 * @param {unknown} node
 * @returns {node is Element}
 */
function element(node) {
  return Boolean(
    node &&
      typeof node === 'object' &&
      // @ts-expect-error Looks like a node.
      node.type === 'element' &&
      // @ts-expect-error Looks like an element.
      typeof node.tagName === 'string'
  )
}


/***/ }),

/***/ "./node_modules/hast-util-to-mdast/node_modules/hast-util-phrasing/lib/index.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/hast-util-to-mdast/node_modules/hast-util-phrasing/lib/index.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   phrasing: () => (/* binding */ phrasing)
/* harmony export */ });
/* harmony import */ var hast_util_is_element__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! hast-util-is-element */ "./node_modules/hast-util-to-mdast/node_modules/hast-util-is-element/index.js");
/* harmony import */ var hast_util_has_property__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! hast-util-has-property */ "./node_modules/hast-util-to-mdast/node_modules/hast-util-has-property/lib/index.js");
/* harmony import */ var hast_util_embedded__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! hast-util-embedded */ "./node_modules/hast-util-to-mdast/node_modules/hast-util-embedded/lib/index.js");
/* harmony import */ var hast_util_is_body_ok_link__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! hast-util-is-body-ok-link */ "./node_modules/hast-util-to-mdast/node_modules/hast-util-is-body-ok-link/index.js");
/**
 * @typedef {import('hast').Root} Root
 * @typedef {import('hast').Content} Content
 */

/**
 * @typedef {Root | Content} Node
 */






const basic = (0,hast_util_is_element__WEBPACK_IMPORTED_MODULE_0__.convertElement)([
  'a',
  'abbr',
  // `area` is in fact only phrasing if it is inside a `map` element.
  // However, since `area`s are required to be inside a `map` element, and it’s
  // a rather involved check, it’s ignored here for now.
  'area',
  'b',
  'bdi',
  'bdo',
  'br',
  'button',
  'cite',
  'code',
  'data',
  'datalist',
  'del',
  'dfn',
  'em',
  'i',
  'input',
  'ins',
  'kbd',
  'keygen',
  'label',
  'map',
  'mark',
  'meter',
  'noscript',
  'output',
  'progress',
  'q',
  'ruby',
  's',
  'samp',
  'script',
  'select',
  'small',
  'span',
  'strong',
  'sub',
  'sup',
  'template',
  'textarea',
  'time',
  'u',
  'var',
  'wbr'
])

const meta = (0,hast_util_is_element__WEBPACK_IMPORTED_MODULE_0__.convertElement)('meta')

/**
 * Check if the given value is *phrasing* content.
 *
 * @param {unknown} value
 *   Thing to check, typically `Node`.
 * @returns {boolean}
 *   Whether `value` is phrasing content.
 */
function phrasing(value) {
  return Boolean(
    node(value) &&
      (value.type === 'text' ||
        basic(value) ||
        (0,hast_util_embedded__WEBPACK_IMPORTED_MODULE_1__.embedded)(value) ||
        (0,hast_util_is_body_ok_link__WEBPACK_IMPORTED_MODULE_2__.isBodyOkLink)(value) ||
        (meta(value) && (0,hast_util_has_property__WEBPACK_IMPORTED_MODULE_3__.hasProperty)(value, 'itemProp')))
  )
}

/**
 * @param {unknown} value
 * @returns {value is Node}
 */
function node(value) {
  // @ts-expect-error: looks like an object.
  return value && typeof value === 'object' && 'type' in value
}


/***/ }),

/***/ "./node_modules/hast-util-to-mdast/node_modules/unist-util-is/lib/index.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/hast-util-to-mdast/node_modules/unist-util-is/lib/index.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   convert: () => (/* binding */ convert),
/* harmony export */   is: () => (/* binding */ is)
/* harmony export */ });
/**
 * @typedef {import('unist').Node} Node
 * @typedef {import('unist').Parent} Parent
 */

/**
 * @typedef {Record<string, unknown>} Props
 * @typedef {null | undefined | string | Props | TestFunctionAnything | Array<string | Props | TestFunctionAnything>} Test
 *   Check for an arbitrary node, unaware of TypeScript inferral.
 *
 * @callback TestFunctionAnything
 *   Check if a node passes a test, unaware of TypeScript inferral.
 * @param {unknown} this
 *   The given context.
 * @param {Node} node
 *   A node.
 * @param {number | null | undefined} [index]
 *   The node’s position in its parent.
 * @param {Parent | null | undefined} [parent]
 *   The node’s parent.
 * @returns {boolean | void}
 *   Whether this node passes the test.
 */

/**
 * @template {Node} Kind
 *   Node type.
 * @typedef {Kind['type'] | Partial<Kind> | TestFunctionPredicate<Kind> | Array<Kind['type'] | Partial<Kind> | TestFunctionPredicate<Kind>>} PredicateTest
 *   Check for a node that can be inferred by TypeScript.
 */

/**
 * Check if a node passes a certain test.
 *
 * @template {Node} Kind
 *   Node type.
 * @callback TestFunctionPredicate
 *   Complex test function for a node that can be inferred by TypeScript.
 * @param {Node} node
 *   A node.
 * @param {number | null | undefined} [index]
 *   The node’s position in its parent.
 * @param {Parent | null | undefined} [parent]
 *   The node’s parent.
 * @returns {node is Kind}
 *   Whether this node passes the test.
 */

/**
 * @callback AssertAnything
 *   Check that an arbitrary value is a node, unaware of TypeScript inferral.
 * @param {unknown} [node]
 *   Anything (typically a node).
 * @param {number | null | undefined} [index]
 *   The node’s position in its parent.
 * @param {Parent | null | undefined} [parent]
 *   The node’s parent.
 * @returns {boolean}
 *   Whether this is a node and passes a test.
 */

/**
 * Check if a node is a node and passes a certain node test.
 *
 * @template {Node} Kind
 *   Node type.
 * @callback AssertPredicate
 *   Check that an arbitrary value is a specific node, aware of TypeScript.
 * @param {unknown} [node]
 *   Anything (typically a node).
 * @param {number | null | undefined} [index]
 *   The node’s position in its parent.
 * @param {Parent | null | undefined} [parent]
 *   The node’s parent.
 * @returns {node is Kind}
 *   Whether this is a node and passes a test.
 */

/**
 * Check if `node` is a `Node` and whether it passes the given test.
 *
 * @param node
 *   Thing to check, typically `Node`.
 * @param test
 *   A check for a specific node.
 * @param index
 *   The node’s position in its parent.
 * @param parent
 *   The node’s parent.
 * @returns
 *   Whether `node` is a node and passes a test.
 */
const is =
  /**
   * @type {(
   *   (() => false) &
   *   (<Kind extends Node = Node>(node: unknown, test: PredicateTest<Kind>, index: number, parent: Parent, context?: unknown) => node is Kind) &
   *   (<Kind extends Node = Node>(node: unknown, test: PredicateTest<Kind>, index?: null | undefined, parent?: null | undefined, context?: unknown) => node is Kind) &
   *   ((node: unknown, test: Test, index: number, parent: Parent, context?: unknown) => boolean) &
   *   ((node: unknown, test?: Test, index?: null | undefined, parent?: null | undefined, context?: unknown) => boolean)
   * )}
   */
  (
    /**
     * @param {unknown} [node]
     * @param {Test} [test]
     * @param {number | null | undefined} [index]
     * @param {Parent | null | undefined} [parent]
     * @param {unknown} [context]
     * @returns {boolean}
     */
    // eslint-disable-next-line max-params
    function is(node, test, index, parent, context) {
      const check = convert(test)

      if (
        index !== undefined &&
        index !== null &&
        (typeof index !== 'number' ||
          index < 0 ||
          index === Number.POSITIVE_INFINITY)
      ) {
        throw new Error('Expected positive finite index')
      }

      if (
        parent !== undefined &&
        parent !== null &&
        (!is(parent) || !parent.children)
      ) {
        throw new Error('Expected parent node')
      }

      if (
        (parent === undefined || parent === null) !==
        (index === undefined || index === null)
      ) {
        throw new Error('Expected both parent and index')
      }

      // @ts-expect-error Looks like a node.
      return node && node.type && typeof node.type === 'string'
        ? Boolean(check.call(context, node, index, parent))
        : false
    }
  )

/**
 * Generate an assertion from a test.
 *
 * Useful if you’re going to test many nodes, for example when creating a
 * utility where something else passes a compatible test.
 *
 * The created function is a bit faster because it expects valid input only:
 * a `node`, `index`, and `parent`.
 *
 * @param test
 *   *   when nullish, checks if `node` is a `Node`.
 *   *   when `string`, works like passing `(node) => node.type === test`.
 *   *   when `function` checks if function passed the node is true.
 *   *   when `object`, checks that all keys in test are in node, and that they have (strictly) equal values.
 *   *   when `array`, checks if any one of the subtests pass.
 * @returns
 *   An assertion.
 */
const convert =
  /**
   * @type {(
   *   (<Kind extends Node>(test: PredicateTest<Kind>) => AssertPredicate<Kind>) &
   *   ((test?: Test) => AssertAnything)
   * )}
   */
  (
    /**
     * @param {Test} [test]
     * @returns {AssertAnything}
     */
    function (test) {
      if (test === undefined || test === null) {
        return ok
      }

      if (typeof test === 'string') {
        return typeFactory(test)
      }

      if (typeof test === 'object') {
        return Array.isArray(test) ? anyFactory(test) : propsFactory(test)
      }

      if (typeof test === 'function') {
        return castFactory(test)
      }

      throw new Error('Expected function, string, or object as test')
    }
  )

/**
 * @param {Array<string | Props | TestFunctionAnything>} tests
 * @returns {AssertAnything}
 */
function anyFactory(tests) {
  /** @type {Array<AssertAnything>} */
  const checks = []
  let index = -1

  while (++index < tests.length) {
    checks[index] = convert(tests[index])
  }

  return castFactory(any)

  /**
   * @this {unknown}
   * @param {Array<unknown>} parameters
   * @returns {boolean}
   */
  function any(...parameters) {
    let index = -1

    while (++index < checks.length) {
      if (checks[index].call(this, ...parameters)) return true
    }

    return false
  }
}

/**
 * Turn an object into a test for a node with a certain fields.
 *
 * @param {Props} check
 * @returns {AssertAnything}
 */
function propsFactory(check) {
  return castFactory(all)

  /**
   * @param {Node} node
   * @returns {boolean}
   */
  function all(node) {
    /** @type {string} */
    let key

    for (key in check) {
      // @ts-expect-error: hush, it sure works as an index.
      if (node[key] !== check[key]) return false
    }

    return true
  }
}

/**
 * Turn a string into a test for a node with a certain type.
 *
 * @param {string} check
 * @returns {AssertAnything}
 */
function typeFactory(check) {
  return castFactory(type)

  /**
   * @param {Node} node
   */
  function type(node) {
    return node && node.type === check
  }
}

/**
 * Turn a custom test into a test for a node that passes that test.
 *
 * @param {TestFunctionAnything} check
 * @returns {AssertAnything}
 */
function castFactory(check) {
  return assertion

  /**
   * @this {unknown}
   * @param {unknown} node
   * @param {Array<unknown>} parameters
   * @returns {boolean}
   */
  function assertion(node, ...parameters) {
    return Boolean(
      node &&
        typeof node === 'object' &&
        'type' in node &&
        // @ts-expect-error: fine.
        Boolean(check.call(this, node, ...parameters))
    )
  }
}

function ok() {
  return true
}


/***/ }),

/***/ "./node_modules/hast-util-to-text/lib/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/hast-util-to-text/lib/index.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   toText: () => (/* binding */ toText)
/* harmony export */ });
/* harmony import */ var hast_util_is_element__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! hast-util-is-element */ "./node_modules/hast-util-to-text/node_modules/hast-util-is-element/index.js");
/* harmony import */ var unist_util_find_after__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! unist-util-find-after */ "./node_modules/unist-util-find-after/lib/index.js");
/**
 * @typedef {import('hast-util-is-element').TestFunctionAnything} TestFunctionAnything
 * @typedef {import('hast').Content} Content
 * @typedef {import('hast').Text} Text
 * @typedef {import('hast').Comment} Comment
 * @typedef {import('hast').Root} Root
 * @typedef {import('hast').Element} Element
 */

/**
 * @typedef {Content | Root} Node
 *   Any node.
 * @typedef {Extract<Node, import('unist').Parent>} Parent
 *   Any parent.
 * @typedef {'normal' | 'pre' | 'nowrap' | 'pre-wrap'} Whitespace
 *   Valid and useful whitespace values (from CSS).
 * @typedef {0 | 1 | 2} BreakNumber
 *   Specific break:
 *
 *   *   `0` — space
 *   *   `1` — line ending
 *   *   `2` — blank line
 * @typedef {'\n'} BreakForce
 *   Forced break.
 * @typedef {boolean} BreakValue
 *   Whether there was a break.
 * @typedef {BreakValue | BreakNumber | undefined} BreakBefore
 *   Any value for a break before.
 * @typedef {BreakValue | BreakNumber | BreakForce | undefined} BreakAfter
 *   Any value for a break after.
 *
 * @typedef CollectionInfo
 *   Info on current collection.
 * @property {Whitespace} whitespace
 *   Current whitespace setting.
 * @property {BreakBefore} breakBefore
 *   Whether there was a break before.
 * @property {BreakAfter} breakAfter
 *   Whether there was a break after.
 *
 * @typedef Options
 *   Configuration.
 * @property {Whitespace | null | undefined} [whitespace='normal']
 *   Initial CSS whitespace setting to use.
 */




const searchLineFeeds = /\n/g
const searchTabOrSpaces = /[\t ]+/g

const br = (0,hast_util_is_element__WEBPACK_IMPORTED_MODULE_0__.convertElement)('br')
const p = (0,hast_util_is_element__WEBPACK_IMPORTED_MODULE_0__.convertElement)('p')
const cell = (0,hast_util_is_element__WEBPACK_IMPORTED_MODULE_0__.convertElement)(['th', 'td'])
const row = (0,hast_util_is_element__WEBPACK_IMPORTED_MODULE_0__.convertElement)('tr')

// Note that we don’t need to include void elements here as they don’t have text.
// See: <https://github.com/wooorm/html-void-elements>
const notRendered = (0,hast_util_is_element__WEBPACK_IMPORTED_MODULE_0__.convertElement)([
  // List from: <https://html.spec.whatwg.org/#hidden-elements>
  'datalist',
  'head',
  'noembed',
  'noframes',
  'noscript', // Act as if we support scripting.
  'rp',
  'script',
  'style',
  'template',
  'title',
  // Hidden attribute.
  hidden,
  // From: <https://html.spec.whatwg.org/#flow-content-3>
  closedDialog
])

// See: <https://html.spec.whatwg.org/#the-css-user-agent-style-sheet-and-presentational-hints>
const blockOrCaption = (0,hast_util_is_element__WEBPACK_IMPORTED_MODULE_0__.convertElement)([
  'address', // Flow content
  'article', // Sections and headings
  'aside', // Sections and headings
  'blockquote', // Flow content
  'body', // Page
  'caption', // `table-caption`
  'center', // Flow content (legacy)
  'dd', // Lists
  'dialog', // Flow content
  'dir', // Lists (legacy)
  'dl', // Lists
  'dt', // Lists
  'div', // Flow content
  'figure', // Flow content
  'figcaption', // Flow content
  'footer', // Flow content
  'form,', // Flow content
  'h1', // Sections and headings
  'h2', // Sections and headings
  'h3', // Sections and headings
  'h4', // Sections and headings
  'h5', // Sections and headings
  'h6', // Sections and headings
  'header', // Flow content
  'hgroup', // Sections and headings
  'hr', // Flow content
  'html', // Page
  'legend', // Flow content
  'listing', // Flow content (legacy)
  'main', // Flow content
  'menu', // Lists
  'nav', // Sections and headings
  'ol', // Lists
  'p', // Flow content
  'plaintext', // Flow content (legacy)
  'pre', // Flow content
  'section', // Sections and headings
  'ul', // Lists
  'xmp' // Flow content (legacy)
])

/**
 * Get the plain-text value of a node.
 *
 * ###### Algorithm
 *
 * *   if `tree` is a comment, returns its `value`
 * *   if `tree` is a text, applies normal whitespace collapsing to its
 *     `value`, as defined by the CSS Text spec
 * *   if `tree` is a root or element, applies an algorithm similar to the
 *     `innerText` getter as defined by HTML
 *
 * ###### Notes
 *
 * > 👉 **Note**: the algorithm acts as if `tree` is being rendered, and as if
 * > we’re a CSS-supporting user agent, with scripting enabled.
 *
 * *   if `tree` is an element that is not displayed (such as a `head`), we’ll
 *     still use the `innerText` algorithm instead of switching to `textContent`
 * *   if descendants of `tree` are elements that are not displayed, they are
 *     ignored
 * *   CSS is not considered, except for the default user agent style sheet
 * *   a line feed is collapsed instead of ignored in cases where Fullwidth, Wide,
 *     or Halfwidth East Asian Width characters are used, the same goes for a case
 *     with Chinese, Japanese, or Yi writing systems
 * *   replaced elements (such as `audio`) are treated like non-replaced elements
 *
 * @param {Node} tree
 *   Tree to turn into text.
 * @param {Options} [options]
 *   Configuration (optional).
 * @returns {string}
 *   Serialized `tree`.
 */
function toText(tree, options = {}) {
  const children = 'children' in tree ? tree.children : []
  const block = blockOrCaption(tree)
  const whitespace = inferWhitespace(tree, {
    whitespace: options.whitespace || 'normal',
    breakBefore: false,
    breakAfter: false
  })

  /** @type {Array<string | BreakNumber>} */
  const results = []

  // Treat `text` and `comment` as having normal white-space.
  // This deviates from the spec as in the DOM the node’s `.data` has to be
  // returned.
  // If you want that behavior use `hast-util-to-string`.
  // All other nodes are later handled as if they are `element`s (so the
  // algorithm also works on a `root`).
  // Nodes without children are treated as a void element, so `doctype` is thus
  // ignored.
  if (tree.type === 'text' || tree.type === 'comment') {
    results.push(
      ...collectText(tree, {
        whitespace,
        breakBefore: true,
        breakAfter: true
      })
    )
  }

  // 1.  If this element is not being rendered, or if the user agent is a
  //     non-CSS user agent, then return the same value as the textContent IDL
  //     attribute on this element.
  //
  //     Note: we’re not supporting stylesheets so we’re acting as if the node
  //     is rendered.
  //
  //     If you want that behavior use `hast-util-to-string`.
  //     Important: we’ll have to account for this later though.

  // 2.  Let results be a new empty list.
  let index = -1

  // 3.  For each child node node of this element:
  while (++index < children.length) {
    // 3.1. Let current be the list resulting in running the inner text
    //      collection steps with node.
    //      Each item in results will either be a JavaScript string or a
    //      positive integer (a required line break count).
    // 3.2. For each item item in current, append item to results.
    results.push(
      // @ts-expect-error Looks like a parent.
      ...innerTextCollection(children[index], tree, {
        whitespace,
        breakBefore: index ? undefined : block,
        breakAfter:
          index < children.length - 1 ? br(children[index + 1]) : block
      })
    )
  }

  // 4.  Remove any items from results that are the empty string.
  // 5.  Remove any runs of consecutive required line break count items at the
  //     start or end of results.
  // 6.  Replace each remaining run of consecutive required line break count
  //     items with a string consisting of as many U+000A LINE FEED (LF)
  //     characters as the maximum of the values in the required line break
  //     count items.
  /** @type {Array<string>} */
  const result = []
  /** @type {number | undefined} */
  let count

  index = -1

  while (++index < results.length) {
    const value = results[index]

    if (typeof value === 'number') {
      if (count !== undefined && value > count) count = value
    } else if (value) {
      if (count !== undefined && count > -1) {
        result.push('\n'.repeat(count) || ' ')
      }

      count = -1
      result.push(value)
    }
  }

  // 7.  Return the concatenation of the string items in results.
  return result.join('')
}

/**
 * <https://html.spec.whatwg.org/#inner-text-collection-steps>
 *
 * @param {Node} node
 * @param {Parent} parent
 * @param {CollectionInfo} info
 * @returns {Array<string | BreakNumber>}
 */
function innerTextCollection(node, parent, info) {
  if (node.type === 'element') {
    return collectElement(node, parent, info)
  }

  if (node.type === 'text') {
    return info.whitespace === 'normal'
      ? collectText(node, info)
      : collectPreText(node)
  }

  return []
}

/**
 * Collect an element.
 *
 * @param {Element} node
 *   Element node.
 * @param {Parent} parent
 * @param {CollectionInfo} info
 *   Info on current collection.
 * @returns {Array<string | BreakNumber>}
 */
function collectElement(node, parent, info) {
  // First we infer the `white-space` property.
  const whitespace = inferWhitespace(node, info)
  const children = node.children || []
  let index = -1
  /** @type {Array<string | BreakNumber>} */
  let items = []

  // We’re ignoring point 3, and exiting without any content here, because we
  // deviated from the spec in `toText` at step 3.
  if (notRendered(node)) {
    return items
  }

  /** @type {BreakNumber | undefined} */
  let prefix
  /** @type {BreakNumber | BreakForce | undefined} */
  let suffix
  // Note: we first detect if there is going to be a break before or after the
  // contents, as that changes the white-space handling.

  // 2.  If node’s computed value of `visibility` is not `visible`, then return
  //     items.
  //
  //     Note: Ignored, as everything is visible by default user agent styles.

  // 3.  If node is not being rendered, then return items. [...]
  //
  //     Note: We already did this above.

  // See `collectText` for step 4.

  // 5.  If node is a `<br>` element, then append a string containing a single
  //     U+000A LINE FEED (LF) character to items.
  if (br(node)) {
    suffix = '\n'
  }

  // 7.  If node’s computed value of `display` is `table-row`, and node’s CSS
  //     box is not the last `table-row` box of the nearest ancestor `table`
  //     box, then append a string containing a single U+000A LINE FEED (LF)
  //     character to items.
  //
  //     See: <https://html.spec.whatwg.org/#tables-2>
  //     Note: needs further investigation as this does not account for implicit
  //     rows.
  else if (row(node) && (0,unist_util_find_after__WEBPACK_IMPORTED_MODULE_1__.findAfter)(parent, node, row)) {
    suffix = '\n'
  }

  // 8.  If node is a `<p>` element, then append 2 (a required line break count)
  //     at the beginning and end of items.
  else if (p(node)) {
    prefix = 2
    suffix = 2
  }

  // 9.  If node’s used value of `display` is block-level or `table-caption`,
  //     then append 1 (a required line break count) at the beginning and end of
  //     items.
  else if (blockOrCaption(node)) {
    prefix = 1
    suffix = 1
  }

  // 1.  Let items be the result of running the inner text collection steps with
  //     each child node of node in tree order, and then concatenating the
  //     results to a single list.
  while (++index < children.length) {
    items = items.concat(
      innerTextCollection(children[index], node, {
        whitespace,
        breakBefore: index ? undefined : prefix,
        breakAfter:
          index < children.length - 1 ? br(children[index + 1]) : suffix
      })
    )
  }

  // 6.  If node’s computed value of `display` is `table-cell`, and node’s CSS
  //     box is not the last `table-cell` box of its enclosing `table-row` box,
  //     then append a string containing a single U+0009 CHARACTER TABULATION
  //     (tab) character to items.
  //
  //     See: <https://html.spec.whatwg.org/#tables-2>
  if (cell(node) && (0,unist_util_find_after__WEBPACK_IMPORTED_MODULE_1__.findAfter)(parent, node, cell)) {
    items.push('\t')
  }

  // Add the pre- and suffix.
  if (prefix) items.unshift(prefix)
  if (suffix) items.push(suffix)

  return items
}

/**
 * 4.  If node is a Text node, then for each CSS text box produced by node,
 *     in content order, compute the text of the box after application of the
 *     CSS `white-space` processing rules and `text-transform` rules, set
 *     items to the list of the resulting strings, and return items.
 *     The CSS `white-space` processing rules are slightly modified:
 *     collapsible spaces at the end of lines are always collapsed, but they
 *     are only removed if the line is the last line of the block, or it ends
 *     with a br element.
 *     Soft hyphens should be preserved.
 *
 *     Note: See `collectText` and `collectPreText`.
 *     Note: we don’t deal with `text-transform`, no element has that by
 *     default.
 *
 * See: <https://drafts.csswg.org/css-text/#white-space-phase-1>
 *
 * @param {Text | Comment} node
 *   Text node.
 * @param {CollectionInfo} info
 *   Info on current collection.
 * @returns {Array<string | BreakNumber>}
 *   Result.
 */
function collectText(node, info) {
  const value = String(node.value)
  /** @type {Array<string>} */
  const lines = []
  /** @type {Array<string | BreakNumber>} */
  const result = []
  let start = 0

  while (start <= value.length) {
    searchLineFeeds.lastIndex = start

    const match = searchLineFeeds.exec(value)
    const end = match && 'index' in match ? match.index : value.length

    lines.push(
      // Any sequence of collapsible spaces and tabs immediately preceding or
      // following a segment break is removed.
      trimAndCollapseSpacesAndTabs(
        // […] ignoring bidi formatting characters (characters with the
        // Bidi_Control property [UAX9]: ALM, LTR, RTL, LRE-RLO, LRI-PDI) as if
        // they were not there.
        value
          .slice(start, end)
          .replace(/[\u061C\u200E\u200F\u202A-\u202E\u2066-\u2069]/g, ''),
        start === 0 ? info.breakBefore : true,
        end === value.length ? info.breakAfter : true
      )
    )

    start = end + 1
  }

  // Collapsible segment breaks are transformed for rendering according to the
  // segment break transformation rules.
  // So here we jump to 4.1.2 of [CSSTEXT]:
  // Any collapsible segment break immediately following another collapsible
  // segment break is removed
  let index = -1
  /** @type {BreakNumber | undefined} */
  let join

  while (++index < lines.length) {
    // *   If the character immediately before or immediately after the segment
    //     break is the zero-width space character (U+200B), then the break is
    //     removed, leaving behind the zero-width space.
    if (
      lines[index].charCodeAt(lines[index].length - 1) === 0x200b /* ZWSP */ ||
      (index < lines.length - 1 &&
        lines[index + 1].charCodeAt(0) === 0x200b) /* ZWSP */
    ) {
      result.push(lines[index])
      join = undefined
    }

    // *   Otherwise, if the East Asian Width property [UAX11] of both the
    //     character before and after the segment break is Fullwidth, Wide, or
    //     Halfwidth (not Ambiguous), and neither side is Hangul, then the
    //     segment break is removed.
    //
    //     Note: ignored.
    // *   Otherwise, if the writing system of the segment break is Chinese,
    //     Japanese, or Yi, and the character before or after the segment break
    //     is punctuation or a symbol (Unicode general category P* or S*) and
    //     has an East Asian Width property of Ambiguous, and the character on
    //     the other side of the segment break is Fullwidth, Wide, or Halfwidth,
    //     and not Hangul, then the segment break is removed.
    //
    //     Note: ignored.

    // *   Otherwise, the segment break is converted to a space (U+0020).
    else if (lines[index]) {
      if (typeof join === 'number') result.push(join)
      result.push(lines[index])
      join = 0
    } else if (index === 0 || index === lines.length - 1) {
      // If this line is empty, and it’s the first or last, add a space.
      // Note that this function is only called in normal whitespace, so we
      // don’t worry about `pre`.
      result.push(0)
    }
  }

  return result
}

/**
 * Collect a text node as “pre” whitespace.
 *
 * @param {Text} node
 *   Text node.
 * @returns {Array<string | BreakNumber>}
 *   Result.
 */
function collectPreText(node) {
  return [String(node.value)]
}

/**
 * 3.  Every collapsible tab is converted to a collapsible space (U+0020).
 * 4.  Any collapsible space immediately following another collapsible
 *     space—even one outside the boundary of the inline containing that
 *     space, provided both spaces are within the same inline formatting
 *     context—is collapsed to have zero advance width. (It is invisible,
 *     but retains its soft wrap opportunity, if any.)
 *
 * @param {string} value
 *   Value to collapse.
 * @param {BreakBefore} breakBefore
 *   Whether there was a break before.
 * @param {BreakAfter} breakAfter
 *   Whether there was a break after.
 * @returns {string}
 *   Result.
 */
function trimAndCollapseSpacesAndTabs(value, breakBefore, breakAfter) {
  /** @type {Array<string>} */
  const result = []
  let start = 0
  /** @type {number | undefined} */
  let end

  while (start < value.length) {
    searchTabOrSpaces.lastIndex = start
    const match = searchTabOrSpaces.exec(value)
    end = match ? match.index : value.length

    // If we’re not directly after a segment break, but there was white space,
    // add an empty value that will be turned into a space.
    if (!start && !end && match && !breakBefore) {
      result.push('')
    }

    if (start !== end) {
      result.push(value.slice(start, end))
    }

    start = match ? end + match[0].length : end
  }

  // If we reached the end, there was trailing white space, and there’s no
  // segment break after this node, add an empty value that will be turned
  // into a space.
  if (start !== end && !breakAfter) {
    result.push('')
  }

  return result.join(' ')
}

/**
 * Figure out the whitespace of a node.
 *
 * We don’t support void elements here (so `nobr wbr` -> `normal` is ignored).
 *
 * @param {Node} node
 *   Node (typically `Element`).
 * @param {CollectionInfo} info
 *   Info on current collection.
 * @returns {Whitespace}
 *   Applied whitespace.
 */
function inferWhitespace(node, info) {
  if (node.type === 'element') {
    const props = node.properties || {}
    switch (node.tagName) {
      case 'listing':
      case 'plaintext':
      case 'xmp': {
        return 'pre'
      }

      case 'nobr': {
        return 'nowrap'
      }

      case 'pre': {
        return props.wrap ? 'pre-wrap' : 'pre'
      }

      case 'td':
      case 'th': {
        return props.noWrap ? 'nowrap' : info.whitespace
      }

      case 'textarea': {
        return 'pre-wrap'
      }

      default:
    }
  }

  return info.whitespace
}

/** @type {TestFunctionAnything} */
function hidden(node) {
  return Boolean((node.properties || {}).hidden)
}

/** @type {TestFunctionAnything} */
function closedDialog(node) {
  return node.tagName === 'dialog' && !(node.properties || {}).open
}


/***/ }),

/***/ "./node_modules/hast-util-to-text/node_modules/hast-util-is-element/index.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/hast-util-to-text/node_modules/hast-util-is-element/index.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   convertElement: () => (/* binding */ convertElement),
/* harmony export */   isElement: () => (/* binding */ isElement)
/* harmony export */ });
/**
 * @typedef {import('unist').Parent} Parent
 * @typedef {import('hast').Element} Element
 */

/**
 * @typedef {null | undefined | string | TestFunctionAnything | Array<string | TestFunctionAnything>} Test
 *   Check for an arbitrary element, unaware of TypeScript inferral.
 *
 * @callback TestFunctionAnything
 *   Check if an element passes a test, unaware of TypeScript inferral.
 * @param {Element} element
 *   An element.
 * @param {number | null | undefined} [index]
 *   The element’s position in its parent.
 * @param {Parent | null | undefined} [parent]
 *   The element’s parent.
 * @returns {boolean | void}
 *   Whether this element passes the test.
 */

/**
 * @template {Element} T
 *   Element type.
 * @typedef {T['tagName'] | TestFunctionPredicate<T> | Array<T['tagName'] | TestFunctionPredicate<T>>} PredicateTest
 *   Check for an element that can be inferred by TypeScript.
 */

/**
 * Check if an element passes a certain node test.
 *
 * @template {Element} T
 *   Element type.
 * @callback TestFunctionPredicate
 *   Complex test function for an element that can be inferred by TypeScript.
 * @param {Element} element
 *   An element.
 * @param {number | null | undefined} [index]
 *   The element’s position in its parent.
 * @param {Parent | null | undefined} [parent]
 *   The element’s parent.
 * @returns {element is T}
 *   Whether this element passes the test.
 */

/**
 * @callback AssertAnything
 *   Check that an arbitrary value is an element, unaware of TypeScript inferral.
 * @param {unknown} [node]
 *   Anything (typically a node).
 * @param {number | null | undefined} [index]
 *   The node’s position in its parent.
 * @param {Parent | null | undefined} [parent]
 *   The node’s parent.
 * @returns {boolean}
 *   Whether this is an element and passes a test.
 */

/**
 * Check if a node is an element and passes a certain node test
 *
 * @template {Element} T
 *   Element type.
 * @callback AssertPredicate
 *   Check that an arbitrary value is a specific element, aware of TypeScript.
 * @param {unknown} [node]
 *   Anything (typically a node).
 * @param {number | null | undefined} [index]
 *   The node’s position in its parent.
 * @param {Parent | null | undefined} [parent]
 *   The node’s parent.
 * @returns {node is T}
 *   Whether this is an element and passes a test.
 */

/**
 * Check if `node` is an `Element` and whether it passes the given test.
 *
 * @param node
 *   Thing to check, typically `Node`.
 * @param test
 *   A check for a specific element.
 * @param index
 *   The node’s position in its parent.
 * @param parent
 *   The node’s parent.
 * @returns
 *   Whether `node` is an element and passes a test.
 */
const isElement =
  /**
   * @type {(
   *   (() => false) &
   *   (<T extends Element = Element>(node: unknown, test?: PredicateTest<T>, index?: number, parent?: Parent, context?: unknown) => node is T) &
   *   ((node: unknown, test: Test, index?: number, parent?: Parent, context?: unknown) => boolean)
   * )}
   */
  (
    /**
     * @param {unknown} [node]
     * @param {Test | undefined} [test]
     * @param {number | null | undefined} [index]
     * @param {Parent | null | undefined} [parent]
     * @param {unknown} [context]
     * @returns {boolean}
     */
    // eslint-disable-next-line max-params
    function (node, test, index, parent, context) {
      const check = convertElement(test)

      if (
        index !== undefined &&
        index !== null &&
        (typeof index !== 'number' ||
          index < 0 ||
          index === Number.POSITIVE_INFINITY)
      ) {
        throw new Error('Expected positive finite index for child node')
      }

      if (
        parent !== undefined &&
        parent !== null &&
        (!parent.type || !parent.children)
      ) {
        throw new Error('Expected parent node')
      }

      // @ts-expect-error Looks like a node.
      if (!node || !node.type || typeof node.type !== 'string') {
        return false
      }

      if (
        (parent === undefined || parent === null) !==
        (index === undefined || index === null)
      ) {
        throw new Error('Expected both parent and index')
      }

      return check.call(context, node, index, parent)
    }
  )

/**
 * Generate an assertion from a test.
 *
 * Useful if you’re going to test many nodes, for example when creating a
 * utility where something else passes a compatible test.
 *
 * The created function is a bit faster because it expects valid input only:
 * a `node`, `index`, and `parent`.
 *
 * @param test
 *   *  When nullish, checks if `node` is an `Element`.
 *   *  When `string`, works like passing `(element) => element.tagName === test`.
 *   *  When `function` checks if function passed the element is true.
 *   *  When `array`, checks any one of the subtests pass.
 * @returns
 *   An assertion.
 */
const convertElement =
  /**
   * @type {(
   *   (<T extends Element>(test: T['tagName'] | TestFunctionPredicate<T>) => AssertPredicate<T>) &
   *   ((test?: Test) => AssertAnything)
   * )}
   */
  (
    /**
     * @param {Test | null | undefined} [test]
     * @returns {AssertAnything}
     */
    function (test) {
      if (test === undefined || test === null) {
        return element
      }

      if (typeof test === 'string') {
        return tagNameFactory(test)
      }

      if (typeof test === 'object') {
        return anyFactory(test)
      }

      if (typeof test === 'function') {
        return castFactory(test)
      }

      throw new Error('Expected function, string, or array as test')
    }
  )

/**
 * Handle multiple tests.
 *
 * @param {Array<string | TestFunctionAnything>} tests
 * @returns {AssertAnything}
 */
function anyFactory(tests) {
  /** @type {Array<AssertAnything>} */
  const checks = []
  let index = -1

  while (++index < tests.length) {
    checks[index] = convertElement(tests[index])
  }

  return castFactory(any)

  /**
   * @this {unknown}
   * @param {Array<unknown>} parameters
   * @returns {boolean}
   */
  function any(...parameters) {
    let index = -1

    while (++index < checks.length) {
      if (checks[index].call(this, ...parameters)) {
        return true
      }
    }

    return false
  }
}

/**
 * Turn a string into a test for an element with a certain tag name.
 *
 * @param {string} check
 * @returns {AssertAnything}
 */
function tagNameFactory(check) {
  return tagName

  /**
   * @param {unknown} node
   * @returns {boolean}
   */
  function tagName(node) {
    return element(node) && node.tagName === check
  }
}

/**
 * Turn a custom test into a test for an element that passes that test.
 *
 * @param {TestFunctionAnything} check
 * @returns {AssertAnything}
 */
function castFactory(check) {
  return assertion

  /**
   * @this {unknown}
   * @param {unknown} node
   * @param {Array<unknown>} parameters
   * @returns {boolean}
   */
  function assertion(node, ...parameters) {
    // @ts-expect-error: fine.
    return element(node) && Boolean(check.call(this, node, ...parameters))
  }
}

/**
 * Make sure something is an element.
 *
 * @param {unknown} node
 * @returns {node is Element}
 */
function element(node) {
  return Boolean(
    node &&
      typeof node === 'object' &&
      // @ts-expect-error Looks like a node.
      node.type === 'element' &&
      // @ts-expect-error Looks like an element.
      typeof node.tagName === 'string'
  )
}


/***/ }),

/***/ "./node_modules/mdast-util-phrasing/lib/index.js":
/*!*******************************************************!*\
  !*** ./node_modules/mdast-util-phrasing/lib/index.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   phrasing: () => (/* binding */ phrasing)
/* harmony export */ });
/* harmony import */ var unist_util_is__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! unist-util-is */ "./node_modules/mdast-util-phrasing/node_modules/unist-util-is/lib/index.js");
/**
 * @typedef {import('mdast').PhrasingContent} PhrasingContent
 * @typedef {import('unist-util-is').AssertPredicate<PhrasingContent>} AssertPredicatePhrasing
 */



/**
 * Check if the given value is *phrasing content*.
 *
 * @param
 *   Thing to check, typically `Node`.
 * @returns
 *   Whether `value` is phrasing content.
 */
const phrasing = /** @type {AssertPredicatePhrasing} */ (
  (0,unist_util_is__WEBPACK_IMPORTED_MODULE_0__.convert)([
    'break',
    'delete',
    'emphasis',
    'footnote',
    'footnoteReference',
    'image',
    'imageReference',
    'inlineCode',
    'link',
    'linkReference',
    'strong',
    'text'
  ])
)


/***/ }),

/***/ "./node_modules/mdast-util-phrasing/node_modules/unist-util-is/lib/index.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/mdast-util-phrasing/node_modules/unist-util-is/lib/index.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   convert: () => (/* binding */ convert),
/* harmony export */   is: () => (/* binding */ is)
/* harmony export */ });
/**
 * @typedef {import('unist').Node} Node
 * @typedef {import('unist').Parent} Parent
 */

/**
 * @typedef {Record<string, unknown>} Props
 * @typedef {null | undefined | string | Props | TestFunctionAnything | Array<string | Props | TestFunctionAnything>} Test
 *   Check for an arbitrary node, unaware of TypeScript inferral.
 *
 * @callback TestFunctionAnything
 *   Check if a node passes a test, unaware of TypeScript inferral.
 * @param {unknown} this
 *   The given context.
 * @param {Node} node
 *   A node.
 * @param {number | null | undefined} [index]
 *   The node’s position in its parent.
 * @param {Parent | null | undefined} [parent]
 *   The node’s parent.
 * @returns {boolean | void}
 *   Whether this node passes the test.
 */

/**
 * @template {Node} Kind
 *   Node type.
 * @typedef {Kind['type'] | Partial<Kind> | TestFunctionPredicate<Kind> | Array<Kind['type'] | Partial<Kind> | TestFunctionPredicate<Kind>>} PredicateTest
 *   Check for a node that can be inferred by TypeScript.
 */

/**
 * Check if a node passes a certain test.
 *
 * @template {Node} Kind
 *   Node type.
 * @callback TestFunctionPredicate
 *   Complex test function for a node that can be inferred by TypeScript.
 * @param {Node} node
 *   A node.
 * @param {number | null | undefined} [index]
 *   The node’s position in its parent.
 * @param {Parent | null | undefined} [parent]
 *   The node’s parent.
 * @returns {node is Kind}
 *   Whether this node passes the test.
 */

/**
 * @callback AssertAnything
 *   Check that an arbitrary value is a node, unaware of TypeScript inferral.
 * @param {unknown} [node]
 *   Anything (typically a node).
 * @param {number | null | undefined} [index]
 *   The node’s position in its parent.
 * @param {Parent | null | undefined} [parent]
 *   The node’s parent.
 * @returns {boolean}
 *   Whether this is a node and passes a test.
 */

/**
 * Check if a node is a node and passes a certain node test.
 *
 * @template {Node} Kind
 *   Node type.
 * @callback AssertPredicate
 *   Check that an arbitrary value is a specific node, aware of TypeScript.
 * @param {unknown} [node]
 *   Anything (typically a node).
 * @param {number | null | undefined} [index]
 *   The node’s position in its parent.
 * @param {Parent | null | undefined} [parent]
 *   The node’s parent.
 * @returns {node is Kind}
 *   Whether this is a node and passes a test.
 */

/**
 * Check if `node` is a `Node` and whether it passes the given test.
 *
 * @param node
 *   Thing to check, typically `Node`.
 * @param test
 *   A check for a specific node.
 * @param index
 *   The node’s position in its parent.
 * @param parent
 *   The node’s parent.
 * @returns
 *   Whether `node` is a node and passes a test.
 */
const is =
  /**
   * @type {(
   *   (() => false) &
   *   (<Kind extends Node = Node>(node: unknown, test: PredicateTest<Kind>, index: number, parent: Parent, context?: unknown) => node is Kind) &
   *   (<Kind extends Node = Node>(node: unknown, test: PredicateTest<Kind>, index?: null | undefined, parent?: null | undefined, context?: unknown) => node is Kind) &
   *   ((node: unknown, test: Test, index: number, parent: Parent, context?: unknown) => boolean) &
   *   ((node: unknown, test?: Test, index?: null | undefined, parent?: null | undefined, context?: unknown) => boolean)
   * )}
   */
  (
    /**
     * @param {unknown} [node]
     * @param {Test} [test]
     * @param {number | null | undefined} [index]
     * @param {Parent | null | undefined} [parent]
     * @param {unknown} [context]
     * @returns {boolean}
     */
    // eslint-disable-next-line max-params
    function is(node, test, index, parent, context) {
      const check = convert(test)

      if (
        index !== undefined &&
        index !== null &&
        (typeof index !== 'number' ||
          index < 0 ||
          index === Number.POSITIVE_INFINITY)
      ) {
        throw new Error('Expected positive finite index')
      }

      if (
        parent !== undefined &&
        parent !== null &&
        (!is(parent) || !parent.children)
      ) {
        throw new Error('Expected parent node')
      }

      if (
        (parent === undefined || parent === null) !==
        (index === undefined || index === null)
      ) {
        throw new Error('Expected both parent and index')
      }

      // @ts-expect-error Looks like a node.
      return node && node.type && typeof node.type === 'string'
        ? Boolean(check.call(context, node, index, parent))
        : false
    }
  )

/**
 * Generate an assertion from a test.
 *
 * Useful if you’re going to test many nodes, for example when creating a
 * utility where something else passes a compatible test.
 *
 * The created function is a bit faster because it expects valid input only:
 * a `node`, `index`, and `parent`.
 *
 * @param test
 *   *   when nullish, checks if `node` is a `Node`.
 *   *   when `string`, works like passing `(node) => node.type === test`.
 *   *   when `function` checks if function passed the node is true.
 *   *   when `object`, checks that all keys in test are in node, and that they have (strictly) equal values.
 *   *   when `array`, checks if any one of the subtests pass.
 * @returns
 *   An assertion.
 */
const convert =
  /**
   * @type {(
   *   (<Kind extends Node>(test: PredicateTest<Kind>) => AssertPredicate<Kind>) &
   *   ((test?: Test) => AssertAnything)
   * )}
   */
  (
    /**
     * @param {Test} [test]
     * @returns {AssertAnything}
     */
    function (test) {
      if (test === undefined || test === null) {
        return ok
      }

      if (typeof test === 'string') {
        return typeFactory(test)
      }

      if (typeof test === 'object') {
        return Array.isArray(test) ? anyFactory(test) : propsFactory(test)
      }

      if (typeof test === 'function') {
        return castFactory(test)
      }

      throw new Error('Expected function, string, or object as test')
    }
  )

/**
 * @param {Array<string | Props | TestFunctionAnything>} tests
 * @returns {AssertAnything}
 */
function anyFactory(tests) {
  /** @type {Array<AssertAnything>} */
  const checks = []
  let index = -1

  while (++index < tests.length) {
    checks[index] = convert(tests[index])
  }

  return castFactory(any)

  /**
   * @this {unknown}
   * @param {Array<unknown>} parameters
   * @returns {boolean}
   */
  function any(...parameters) {
    let index = -1

    while (++index < checks.length) {
      if (checks[index].call(this, ...parameters)) return true
    }

    return false
  }
}

/**
 * Turn an object into a test for a node with a certain fields.
 *
 * @param {Props} check
 * @returns {AssertAnything}
 */
function propsFactory(check) {
  return castFactory(all)

  /**
   * @param {Node} node
   * @returns {boolean}
   */
  function all(node) {
    /** @type {string} */
    let key

    for (key in check) {
      // @ts-expect-error: hush, it sure works as an index.
      if (node[key] !== check[key]) return false
    }

    return true
  }
}

/**
 * Turn a string into a test for a node with a certain type.
 *
 * @param {string} check
 * @returns {AssertAnything}
 */
function typeFactory(check) {
  return castFactory(type)

  /**
   * @param {Node} node
   */
  function type(node) {
    return node && node.type === check
  }
}

/**
 * Turn a custom test into a test for a node that passes that test.
 *
 * @param {TestFunctionAnything} check
 * @returns {AssertAnything}
 */
function castFactory(check) {
  return assertion

  /**
   * @this {unknown}
   * @param {unknown} node
   * @param {Array<unknown>} parameters
   * @returns {boolean}
   */
  function assertion(node, ...parameters) {
    return Boolean(
      node &&
        typeof node === 'object' &&
        'type' in node &&
        // @ts-expect-error: fine.
        Boolean(check.call(this, node, ...parameters))
    )
  }
}

function ok() {
  return true
}


/***/ }),

/***/ "./node_modules/mdast-util-to-string/lib/index.js":
/*!********************************************************!*\
  !*** ./node_modules/mdast-util-to-string/lib/index.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   toString: () => (/* binding */ toString)
/* harmony export */ });
/**
 * @typedef {import('mdast').Root|import('mdast').Content} Node
 *
 * @typedef Options
 *   Configuration (optional).
 * @property {boolean | null | undefined} [includeImageAlt=true]
 *   Whether to use `alt` for `image`s.
 * @property {boolean | null | undefined} [includeHtml=true]
 *   Whether to use `value` of HTML.
 */

/** @type {Options} */
const emptyOptions = {}

/**
 * Get the text content of a node or list of nodes.
 *
 * Prefers the node’s plain-text fields, otherwise serializes its children,
 * and if the given value is an array, serialize the nodes in it.
 *
 * @param {unknown} value
 *   Thing to serialize, typically `Node`.
 * @param {Options | null | undefined} [options]
 *   Configuration (optional).
 * @returns {string}
 *   Serialized `value`.
 */
function toString(value, options) {
  const settings = options || emptyOptions
  const includeImageAlt =
    typeof settings.includeImageAlt === 'boolean'
      ? settings.includeImageAlt
      : true
  const includeHtml =
    typeof settings.includeHtml === 'boolean' ? settings.includeHtml : true

  return one(value, includeImageAlt, includeHtml)
}

/**
 * One node or several nodes.
 *
 * @param {unknown} value
 *   Thing to serialize.
 * @param {boolean} includeImageAlt
 *   Include image `alt`s.
 * @param {boolean} includeHtml
 *   Include HTML.
 * @returns {string}
 *   Serialized node.
 */
function one(value, includeImageAlt, includeHtml) {
  if (node(value)) {
    if ('value' in value) {
      return value.type === 'html' && !includeHtml ? '' : value.value
    }

    if (includeImageAlt && 'alt' in value && value.alt) {
      return value.alt
    }

    if ('children' in value) {
      return all(value.children, includeImageAlt, includeHtml)
    }
  }

  if (Array.isArray(value)) {
    return all(value, includeImageAlt, includeHtml)
  }

  return ''
}

/**
 * Serialize a list of nodes.
 *
 * @param {Array<unknown>} values
 *   Thing to serialize.
 * @param {boolean} includeImageAlt
 *   Include image `alt`s.
 * @param {boolean} includeHtml
 *   Include HTML.
 * @returns {string}
 *   Serialized nodes.
 */
function all(values, includeImageAlt, includeHtml) {
  /** @type {Array<string>} */
  const result = []
  let index = -1

  while (++index < values.length) {
    result[index] = one(values[index], includeImageAlt, includeHtml)
  }

  return result.join('')
}

/**
 * Check if `value` looks like a node.
 *
 * @param {unknown} value
 *   Thing.
 * @returns {value is Node}
 *   Whether `value` is a node.
 */
function node(value) {
  return Boolean(value && typeof value === 'object')
}


/***/ }),

/***/ "./node_modules/rehype-minify-whitespace/block.js":
/*!********************************************************!*\
  !*** ./node_modules/rehype-minify-whitespace/block.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   blocks: () => (/* binding */ blocks)
/* harmony export */ });
// See: <https://html.spec.whatwg.org/#the-css-user-agent-style-sheet-and-presentational-hints>
const blocks = [
  'address', // Flow content.
  'article', // Sections and headings.
  'aside', // Sections and headings.
  'blockquote', // Flow content.
  'body', // Page.
  'br', // Contribute whitespace intrinsically.
  'caption', // Similar to block.
  'center', // Flow content, legacy.
  'col', // Similar to block.
  'colgroup', // Similar to block.
  'dd', // Lists.
  'dialog', // Flow content.
  'dir', // Lists, legacy.
  'div', // Flow content.
  'dl', // Lists.
  'dt', // Lists.
  'figcaption', // Flow content.
  'figure', // Flow content.
  'footer', // Flow content.
  'form', // Flow content.
  'h1', // Sections and headings.
  'h2', // Sections and headings.
  'h3', // Sections and headings.
  'h4', // Sections and headings.
  'h5', // Sections and headings.
  'h6', // Sections and headings.
  'head', // Page.
  'header', // Flow content.
  'hgroup', // Sections and headings.
  'hr', // Flow content.
  'html', // Page.
  'legend', // Flow content.
  'li', // Block-like.
  'li', // Similar to block.
  'listing', // Flow content, legacy
  'main', // Flow content.
  'menu', // Lists.
  'nav', // Sections and headings.
  'ol', // Lists.
  'optgroup', // Similar to block.
  'option', // Similar to block.
  'p', // Flow content.
  'plaintext', // Flow content, legacy
  'pre', // Flow content.
  'section', // Sections and headings.
  'summary', // Similar to block.
  'table', // Similar to block.
  'tbody', // Similar to block.
  'td', // Block-like.
  'td', // Similar to block.
  'tfoot', // Similar to block.
  'th', // Block-like.
  'th', // Similar to block.
  'thead', // Similar to block.
  'tr', // Similar to block.
  'ul', // Lists.
  'wbr', // Contribute whitespace intrinsically.
  'xmp' // Flow content, legacy
]


/***/ }),

/***/ "./node_modules/rehype-minify-whitespace/content.js":
/*!**********************************************************!*\
  !*** ./node_modules/rehype-minify-whitespace/content.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   content: () => (/* binding */ content)
/* harmony export */ });
const content = [
  // Form.
  'button',
  'input',
  'select',
  'textarea'
]


/***/ }),

/***/ "./node_modules/rehype-minify-whitespace/index.js":
/*!********************************************************!*\
  !*** ./node_modules/rehype-minify-whitespace/index.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ rehypeMinifyWhitespace)
/* harmony export */ });
/* harmony import */ var hast_util_is_element__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! hast-util-is-element */ "./node_modules/rehype-minify-whitespace/node_modules/hast-util-is-element/index.js");
/* harmony import */ var hast_util_embedded__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! hast-util-embedded */ "./node_modules/rehype-minify-whitespace/node_modules/hast-util-embedded/lib/index.js");
/* harmony import */ var unist_util_is__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! unist-util-is */ "./node_modules/rehype-minify-whitespace/node_modules/unist-util-is/lib/index.js");
/* harmony import */ var hast_util_whitespace__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! hast-util-whitespace */ "./node_modules/rehype-minify-whitespace/node_modules/hast-util-whitespace/index.js");
/* harmony import */ var _block_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./block.js */ "./node_modules/rehype-minify-whitespace/block.js");
/* harmony import */ var _content_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./content.js */ "./node_modules/rehype-minify-whitespace/content.js");
/* harmony import */ var _skippable_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./skippable.js */ "./node_modules/rehype-minify-whitespace/skippable.js");
/**
 * rehype plugin to minify whitespace between elements.
 *
 * ## What is this?
 *
 * This package is a plugin that can minify the whitespace between elements.
 *
 * ## When should I use this?
 *
 * You can use this plugin when you want to improve the size of HTML documents.
 *
 * ## API
 *
 * ### `unified().use(rehypeMinifyWhitespace[, options])`
 *
 * Minify whitespace.
 *
 * ##### `options`
 *
 * Configuration (optional).
 *
 * ##### `options.newlines`
 *
 * Whether to collapse runs of whitespace that include line endings to one
 * line ending (`boolean`, default: `false`).
 * The default is to collapse everything to one space.
 *
 * @example
 *   <h1>Heading</h1>
 *   <p><strong>This</strong> and <em>that</em></p>
 */

/**
 * @typedef {import('hast').Root} Root
 * @typedef {import('hast').Element} Element
 * @typedef {import('hast').Text} Text
 * @typedef {Root|Root['children'][number]} Node
 *
 * @typedef Options
 * @property {boolean} [newlines=false]
 *   If `newlines: true`, collapses whitespace containing newlines to `'\n'`
 *   instead of `' '`.
 *   The default is to collapse to a single space.
 *
 * @typedef {'pre'|'nowrap'|'pre-wrap'|'normal'} Whitespace
 *
 * @typedef Context
 * @property {ReturnType<collapseFactory>} collapse
 * @property {Whitespace} whitespace
 * @property {boolean} [before]
 * @property {boolean} [after]
 *
 * @typedef Result
 * @property {boolean} remove
 * @property {boolean} ignore
 * @property {boolean} stripAtStart
 */









const ignorableNode = (0,unist_util_is__WEBPACK_IMPORTED_MODULE_0__.convert)(['doctype', 'comment'])

/**
 * Minify whitespace.
 *
 * @type {import('unified').Plugin<[Options?]|Array<void>, Root>}
 */
function rehypeMinifyWhitespace(options = {}) {
  const collapse = collapseFactory(
    options.newlines ? replaceNewlines : replaceWhitespace
  )

  return (tree) => {
    minify(tree, {collapse, whitespace: 'normal'})
  }
}

/**
 * @param {Node} node
 * @param {Context} context
 * @returns {Result}
 */
function minify(node, context) {
  if ('children' in node) {
    const settings = Object.assign({}, context)

    if (node.type === 'root' || blocklike(node)) {
      settings.before = true
      settings.after = true
    }

    settings.whitespace = inferWhiteSpace(node, context)

    return all(node, settings)
  }

  if (node.type === 'text') {
    if (context.whitespace === 'normal') {
      return minifyText(node, context)
    }

    // Naïve collapse, but no trimming:
    if (context.whitespace === 'nowrap') {
      node.value = context.collapse(node.value)
    }

    // The `pre-wrap` or `pre` whitespace settings are neither collapsed nor
    // trimmed.
  }

  return {remove: false, ignore: ignorableNode(node), stripAtStart: false}
}

/**
 * @param {Text} node
 * @param {Context} context
 * @returns {Result}
 */
function minifyText(node, context) {
  const value = context.collapse(node.value)
  const result = {remove: false, ignore: false, stripAtStart: false}
  let start = 0
  let end = value.length

  if (context.before && removable(value.charAt(0))) {
    start++
  }

  if (start !== end && removable(value.charAt(end - 1))) {
    if (context.after) {
      end--
    } else {
      result.stripAtStart = true
    }
  }

  if (start === end) {
    result.remove = true
  } else {
    node.value = value.slice(start, end)
  }

  return result
}

/**
 * @param {Root|Element} parent
 * @param {Context} context
 * @returns {Result}
 */
function all(parent, context) {
  let before = context.before
  const after = context.after
  const children = parent.children
  let length = children.length
  let index = -1

  while (++index < length) {
    const result = minify(
      children[index],
      Object.assign({}, context, {
        before,
        after: collapsableAfter(children, index, after)
      })
    )

    if (result.remove) {
      children.splice(index, 1)
      index--
      length--
    } else if (!result.ignore) {
      before = result.stripAtStart
    }

    // If this element, such as a `<select>` or `<img>`, contributes content
    // somehow, allow whitespace again.
    if (content(children[index])) {
      before = false
    }
  }

  return {remove: false, ignore: false, stripAtStart: Boolean(before || after)}
}

/**
 * @param {Array<Node>} nodes
 * @param {number} index
 * @param {boolean|undefined} [after]
 * @returns {boolean|undefined}
 */
function collapsableAfter(nodes, index, after) {
  while (++index < nodes.length) {
    const node = nodes[index]
    let result = inferBoundary(node)

    if (result === undefined && 'children' in node && !skippable(node)) {
      result = collapsableAfter(node.children, -1)
    }

    if (typeof result === 'boolean') {
      return result
    }
  }

  return after
}

/**
 * Infer two types of boundaries:
 *
 * 1. `true` — boundary for which whitespace around it does not contribute
 *    anything
 * 2. `false` — boundary for which whitespace around it *does* contribute
 *
 * No result (`undefined`) is returned if it is unknown.
 *
 * @param {Node} node
 * @returns {boolean|undefined}
 */
function inferBoundary(node) {
  if (node.type === 'element') {
    if (content(node)) {
      return false
    }

    if (blocklike(node)) {
      return true
    }

    // Unknown: either depends on siblings if embedded or metadata, or on
    // children.
  } else if (node.type === 'text') {
    if (!(0,hast_util_whitespace__WEBPACK_IMPORTED_MODULE_1__.whitespace)(node)) {
      return false
    }
  } else if (!ignorableNode(node)) {
    return false
  }
}

/**
 * Infer whether a node is skippable.
 *
 * @param {Node} node
 * @returns {boolean}
 */
function content(node) {
  return (0,hast_util_embedded__WEBPACK_IMPORTED_MODULE_2__.embedded)(node) || (0,hast_util_is_element__WEBPACK_IMPORTED_MODULE_3__.isElement)(node, _content_js__WEBPACK_IMPORTED_MODULE_4__.content)
}

/**
 * See: <https://html.spec.whatwg.org/#the-css-user-agent-style-sheet-and-presentational-hints>
 *
 * @param {Element} node
 * @returns {boolean}
 */
function blocklike(node) {
  return (0,hast_util_is_element__WEBPACK_IMPORTED_MODULE_3__.isElement)(node, _block_js__WEBPACK_IMPORTED_MODULE_5__.blocks)
}

/**
 * @param {Element|Root} node
 * @returns {boolean}
 */
function skippable(node) {
  return (
    Boolean(
      'properties' in node && node.properties && node.properties.hidden
    ) ||
    ignorableNode(node) ||
    (0,hast_util_is_element__WEBPACK_IMPORTED_MODULE_3__.isElement)(node, _skippable_js__WEBPACK_IMPORTED_MODULE_6__.skippable)
  )
}

/**
 * @param {string} character
 * @returns {boolean}
 */
function removable(character) {
  return character === ' ' || character === '\n'
}

/**
 * @param {string} value
 * @returns {string}
 */
function replaceNewlines(value) {
  const match = /\r?\n|\r/.exec(value)
  return match ? match[0] : ' '
}

/**
 * @returns {string}
 */
function replaceWhitespace() {
  return ' '
}

/**
 * @param {(value: string) => string} replace
 */
function collapseFactory(replace) {
  return collapse

  /**
   * @param {string} value
   * @returns {string}
   */
  function collapse(value) {
    return String(value).replace(/[\t\n\v\f\r ]+/g, replace)
  }
}

/**
 * We don’t need to support void elements here (so `nobr wbr` -> `normal` is
 * ignored).
 *
 * @param {Root|Element} node
 * @param {Context} context
 * @returns {Whitespace}
 */
function inferWhiteSpace(node, context) {
  if ('tagName' in node && node.properties) {
    switch (node.tagName) {
      // Whitespace in script/style, while not displayed by CSS as significant,
      // could have some meaning in JS/CSS, so we can’t touch them.
      case 'listing':
      case 'plaintext':
      case 'script':
      case 'style':
      case 'xmp':
        return 'pre'
      case 'nobr':
        return 'nowrap'
      case 'pre':
        return node.properties.wrap ? 'pre-wrap' : 'pre'
      case 'td':
      case 'th':
        return node.properties.noWrap ? 'nowrap' : context.whitespace
      case 'textarea':
        return 'pre-wrap'
      default:
    }
  }

  return context.whitespace
}


/***/ }),

/***/ "./node_modules/rehype-minify-whitespace/node_modules/hast-util-embedded/lib/index.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/rehype-minify-whitespace/node_modules/hast-util-embedded/lib/index.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   embedded: () => (/* binding */ embedded)
/* harmony export */ });
/* harmony import */ var hast_util_is_element__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! hast-util-is-element */ "./node_modules/rehype-minify-whitespace/node_modules/hast-util-is-element/index.js");
/**
 * @typedef {import('hast').Element} Element
 */



/**
 * Check if a node is a *embedded content*.
 *
 * @type {import('hast-util-is-element').AssertPredicate<Element & {tagName: 'audio' | 'canvas' | 'embed' | 'iframe' | 'img' | 'math' | 'object' | 'picture' | 'svg' | 'video'}>}
 * @param value
 *   Thing to check (typically `Node`).
 * @returns
 *   Whether `value` is an element considered embedded content.
 *
 *   The elements `audio`, `canvas`, `embed`, `iframe`, `img`, `math`,
 *   `object`, `picture`, `svg`, and `video` are embedded content.
 */
// @ts-expect-error Sure, the assertion matches.
const embedded = (0,hast_util_is_element__WEBPACK_IMPORTED_MODULE_0__.convertElement)([
  'audio',
  'canvas',
  'embed',
  'iframe',
  'img',
  'math',
  'object',
  'picture',
  'svg',
  'video'
])


/***/ }),

/***/ "./node_modules/rehype-minify-whitespace/node_modules/hast-util-is-element/index.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/rehype-minify-whitespace/node_modules/hast-util-is-element/index.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   convertElement: () => (/* binding */ convertElement),
/* harmony export */   isElement: () => (/* binding */ isElement)
/* harmony export */ });
/**
 * @typedef {import('unist').Parent} Parent
 * @typedef {import('hast').Element} Element
 */

/**
 * @typedef {null | undefined | string | TestFunctionAnything | Array<string | TestFunctionAnything>} Test
 *   Check for an arbitrary element, unaware of TypeScript inferral.
 *
 * @callback TestFunctionAnything
 *   Check if an element passes a test, unaware of TypeScript inferral.
 * @param {Element} element
 *   An element.
 * @param {number | null | undefined} [index]
 *   The element’s position in its parent.
 * @param {Parent | null | undefined} [parent]
 *   The element’s parent.
 * @returns {boolean | void}
 *   Whether this element passes the test.
 */

/**
 * @template {Element} T
 *   Element type.
 * @typedef {T['tagName'] | TestFunctionPredicate<T> | Array<T['tagName'] | TestFunctionPredicate<T>>} PredicateTest
 *   Check for an element that can be inferred by TypeScript.
 */

/**
 * Check if an element passes a certain node test.
 *
 * @template {Element} T
 *   Element type.
 * @callback TestFunctionPredicate
 *   Complex test function for an element that can be inferred by TypeScript.
 * @param {Element} element
 *   An element.
 * @param {number | null | undefined} [index]
 *   The element’s position in its parent.
 * @param {Parent | null | undefined} [parent]
 *   The element’s parent.
 * @returns {element is T}
 *   Whether this element passes the test.
 */

/**
 * @callback AssertAnything
 *   Check that an arbitrary value is an element, unaware of TypeScript inferral.
 * @param {unknown} [node]
 *   Anything (typically a node).
 * @param {number | null | undefined} [index]
 *   The node’s position in its parent.
 * @param {Parent | null | undefined} [parent]
 *   The node’s parent.
 * @returns {boolean}
 *   Whether this is an element and passes a test.
 */

/**
 * Check if a node is an element and passes a certain node test
 *
 * @template {Element} T
 *   Element type.
 * @callback AssertPredicate
 *   Check that an arbitrary value is a specific element, aware of TypeScript.
 * @param {unknown} [node]
 *   Anything (typically a node).
 * @param {number | null | undefined} [index]
 *   The node’s position in its parent.
 * @param {Parent | null | undefined} [parent]
 *   The node’s parent.
 * @returns {node is T}
 *   Whether this is an element and passes a test.
 */

/**
 * Check if `node` is an `Element` and whether it passes the given test.
 *
 * @param node
 *   Thing to check, typically `Node`.
 * @param test
 *   A check for a specific element.
 * @param index
 *   The node’s position in its parent.
 * @param parent
 *   The node’s parent.
 * @returns
 *   Whether `node` is an element and passes a test.
 */
const isElement =
  /**
   * @type {(
   *   (() => false) &
   *   (<T extends Element = Element>(node: unknown, test?: PredicateTest<T>, index?: number, parent?: Parent, context?: unknown) => node is T) &
   *   ((node: unknown, test: Test, index?: number, parent?: Parent, context?: unknown) => boolean)
   * )}
   */
  (
    /**
     * @param {unknown} [node]
     * @param {Test | undefined} [test]
     * @param {number | null | undefined} [index]
     * @param {Parent | null | undefined} [parent]
     * @param {unknown} [context]
     * @returns {boolean}
     */
    // eslint-disable-next-line max-params
    function (node, test, index, parent, context) {
      const check = convertElement(test)

      if (
        index !== undefined &&
        index !== null &&
        (typeof index !== 'number' ||
          index < 0 ||
          index === Number.POSITIVE_INFINITY)
      ) {
        throw new Error('Expected positive finite index for child node')
      }

      if (
        parent !== undefined &&
        parent !== null &&
        (!parent.type || !parent.children)
      ) {
        throw new Error('Expected parent node')
      }

      // @ts-expect-error Looks like a node.
      if (!node || !node.type || typeof node.type !== 'string') {
        return false
      }

      if (
        (parent === undefined || parent === null) !==
        (index === undefined || index === null)
      ) {
        throw new Error('Expected both parent and index')
      }

      return check.call(context, node, index, parent)
    }
  )

/**
 * Generate an assertion from a test.
 *
 * Useful if you’re going to test many nodes, for example when creating a
 * utility where something else passes a compatible test.
 *
 * The created function is a bit faster because it expects valid input only:
 * a `node`, `index`, and `parent`.
 *
 * @param test
 *   *  When nullish, checks if `node` is an `Element`.
 *   *  When `string`, works like passing `(element) => element.tagName === test`.
 *   *  When `function` checks if function passed the element is true.
 *   *  When `array`, checks any one of the subtests pass.
 * @returns
 *   An assertion.
 */
const convertElement =
  /**
   * @type {(
   *   (<T extends Element>(test: T['tagName'] | TestFunctionPredicate<T>) => AssertPredicate<T>) &
   *   ((test?: Test) => AssertAnything)
   * )}
   */
  (
    /**
     * @param {Test | null | undefined} [test]
     * @returns {AssertAnything}
     */
    function (test) {
      if (test === undefined || test === null) {
        return element
      }

      if (typeof test === 'string') {
        return tagNameFactory(test)
      }

      if (typeof test === 'object') {
        return anyFactory(test)
      }

      if (typeof test === 'function') {
        return castFactory(test)
      }

      throw new Error('Expected function, string, or array as test')
    }
  )

/**
 * Handle multiple tests.
 *
 * @param {Array<string | TestFunctionAnything>} tests
 * @returns {AssertAnything}
 */
function anyFactory(tests) {
  /** @type {Array<AssertAnything>} */
  const checks = []
  let index = -1

  while (++index < tests.length) {
    checks[index] = convertElement(tests[index])
  }

  return castFactory(any)

  /**
   * @this {unknown}
   * @param {Array<unknown>} parameters
   * @returns {boolean}
   */
  function any(...parameters) {
    let index = -1

    while (++index < checks.length) {
      if (checks[index].call(this, ...parameters)) {
        return true
      }
    }

    return false
  }
}

/**
 * Turn a string into a test for an element with a certain tag name.
 *
 * @param {string} check
 * @returns {AssertAnything}
 */
function tagNameFactory(check) {
  return tagName

  /**
   * @param {unknown} node
   * @returns {boolean}
   */
  function tagName(node) {
    return element(node) && node.tagName === check
  }
}

/**
 * Turn a custom test into a test for an element that passes that test.
 *
 * @param {TestFunctionAnything} check
 * @returns {AssertAnything}
 */
function castFactory(check) {
  return assertion

  /**
   * @this {unknown}
   * @param {unknown} node
   * @param {Array<unknown>} parameters
   * @returns {boolean}
   */
  function assertion(node, ...parameters) {
    // @ts-expect-error: fine.
    return element(node) && Boolean(check.call(this, node, ...parameters))
  }
}

/**
 * Make sure something is an element.
 *
 * @param {unknown} node
 * @returns {node is Element}
 */
function element(node) {
  return Boolean(
    node &&
      typeof node === 'object' &&
      // @ts-expect-error Looks like a node.
      node.type === 'element' &&
      // @ts-expect-error Looks like an element.
      typeof node.tagName === 'string'
  )
}


/***/ }),

/***/ "./node_modules/rehype-minify-whitespace/node_modules/hast-util-whitespace/index.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/rehype-minify-whitespace/node_modules/hast-util-whitespace/index.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   whitespace: () => (/* binding */ whitespace)
/* harmony export */ });
/**
 * Check if the given value is *inter-element whitespace*.
 *
 * @param {unknown} thing
 *   Thing to check (typically `Node` or `string`).
 * @returns {boolean}
 *   Whether the `value` is inter-element whitespace (`boolean`): consisting of
 *   zero or more of space, tab (`\t`), line feed (`\n`), carriage return
 *   (`\r`), or form feed (`\f`).
 *   If a node is passed it must be a `Text` node, whose `value` field is
 *   checked.
 */
function whitespace(thing) {
  /** @type {string} */
  const value =
    // @ts-expect-error looks like a node.
    thing && typeof thing === 'object' && thing.type === 'text'
      ? // @ts-expect-error looks like a text.
        thing.value || ''
      : thing

  // HTML whitespace expression.
  // See <https://infra.spec.whatwg.org/#ascii-whitespace>.
  return typeof value === 'string' && value.replace(/[ \t\n\f\r]/g, '') === ''
}


/***/ }),

/***/ "./node_modules/rehype-minify-whitespace/node_modules/unist-util-is/lib/index.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/rehype-minify-whitespace/node_modules/unist-util-is/lib/index.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   convert: () => (/* binding */ convert),
/* harmony export */   is: () => (/* binding */ is)
/* harmony export */ });
/**
 * @typedef {import('unist').Node} Node
 * @typedef {import('unist').Parent} Parent
 */

/**
 * @typedef {Record<string, unknown>} Props
 * @typedef {null | undefined | string | Props | TestFunctionAnything | Array<string | Props | TestFunctionAnything>} Test
 *   Check for an arbitrary node, unaware of TypeScript inferral.
 *
 * @callback TestFunctionAnything
 *   Check if a node passes a test, unaware of TypeScript inferral.
 * @param {unknown} this
 *   The given context.
 * @param {Node} node
 *   A node.
 * @param {number | null | undefined} [index]
 *   The node’s position in its parent.
 * @param {Parent | null | undefined} [parent]
 *   The node’s parent.
 * @returns {boolean | void}
 *   Whether this node passes the test.
 */

/**
 * @template {Node} Kind
 *   Node type.
 * @typedef {Kind['type'] | Partial<Kind> | TestFunctionPredicate<Kind> | Array<Kind['type'] | Partial<Kind> | TestFunctionPredicate<Kind>>} PredicateTest
 *   Check for a node that can be inferred by TypeScript.
 */

/**
 * Check if a node passes a certain test.
 *
 * @template {Node} Kind
 *   Node type.
 * @callback TestFunctionPredicate
 *   Complex test function for a node that can be inferred by TypeScript.
 * @param {Node} node
 *   A node.
 * @param {number | null | undefined} [index]
 *   The node’s position in its parent.
 * @param {Parent | null | undefined} [parent]
 *   The node’s parent.
 * @returns {node is Kind}
 *   Whether this node passes the test.
 */

/**
 * @callback AssertAnything
 *   Check that an arbitrary value is a node, unaware of TypeScript inferral.
 * @param {unknown} [node]
 *   Anything (typically a node).
 * @param {number | null | undefined} [index]
 *   The node’s position in its parent.
 * @param {Parent | null | undefined} [parent]
 *   The node’s parent.
 * @returns {boolean}
 *   Whether this is a node and passes a test.
 */

/**
 * Check if a node is a node and passes a certain node test.
 *
 * @template {Node} Kind
 *   Node type.
 * @callback AssertPredicate
 *   Check that an arbitrary value is a specific node, aware of TypeScript.
 * @param {unknown} [node]
 *   Anything (typically a node).
 * @param {number | null | undefined} [index]
 *   The node’s position in its parent.
 * @param {Parent | null | undefined} [parent]
 *   The node’s parent.
 * @returns {node is Kind}
 *   Whether this is a node and passes a test.
 */

/**
 * Check if `node` is a `Node` and whether it passes the given test.
 *
 * @param node
 *   Thing to check, typically `Node`.
 * @param test
 *   A check for a specific node.
 * @param index
 *   The node’s position in its parent.
 * @param parent
 *   The node’s parent.
 * @returns
 *   Whether `node` is a node and passes a test.
 */
const is =
  /**
   * @type {(
   *   (() => false) &
   *   (<Kind extends Node = Node>(node: unknown, test: PredicateTest<Kind>, index: number, parent: Parent, context?: unknown) => node is Kind) &
   *   (<Kind extends Node = Node>(node: unknown, test: PredicateTest<Kind>, index?: null | undefined, parent?: null | undefined, context?: unknown) => node is Kind) &
   *   ((node: unknown, test: Test, index: number, parent: Parent, context?: unknown) => boolean) &
   *   ((node: unknown, test?: Test, index?: null | undefined, parent?: null | undefined, context?: unknown) => boolean)
   * )}
   */
  (
    /**
     * @param {unknown} [node]
     * @param {Test} [test]
     * @param {number | null | undefined} [index]
     * @param {Parent | null | undefined} [parent]
     * @param {unknown} [context]
     * @returns {boolean}
     */
    // eslint-disable-next-line max-params
    function is(node, test, index, parent, context) {
      const check = convert(test)

      if (
        index !== undefined &&
        index !== null &&
        (typeof index !== 'number' ||
          index < 0 ||
          index === Number.POSITIVE_INFINITY)
      ) {
        throw new Error('Expected positive finite index')
      }

      if (
        parent !== undefined &&
        parent !== null &&
        (!is(parent) || !parent.children)
      ) {
        throw new Error('Expected parent node')
      }

      if (
        (parent === undefined || parent === null) !==
        (index === undefined || index === null)
      ) {
        throw new Error('Expected both parent and index')
      }

      // @ts-expect-error Looks like a node.
      return node && node.type && typeof node.type === 'string'
        ? Boolean(check.call(context, node, index, parent))
        : false
    }
  )

/**
 * Generate an assertion from a test.
 *
 * Useful if you’re going to test many nodes, for example when creating a
 * utility where something else passes a compatible test.
 *
 * The created function is a bit faster because it expects valid input only:
 * a `node`, `index`, and `parent`.
 *
 * @param test
 *   *   when nullish, checks if `node` is a `Node`.
 *   *   when `string`, works like passing `(node) => node.type === test`.
 *   *   when `function` checks if function passed the node is true.
 *   *   when `object`, checks that all keys in test are in node, and that they have (strictly) equal values.
 *   *   when `array`, checks if any one of the subtests pass.
 * @returns
 *   An assertion.
 */
const convert =
  /**
   * @type {(
   *   (<Kind extends Node>(test: PredicateTest<Kind>) => AssertPredicate<Kind>) &
   *   ((test?: Test) => AssertAnything)
   * )}
   */
  (
    /**
     * @param {Test} [test]
     * @returns {AssertAnything}
     */
    function (test) {
      if (test === undefined || test === null) {
        return ok
      }

      if (typeof test === 'string') {
        return typeFactory(test)
      }

      if (typeof test === 'object') {
        return Array.isArray(test) ? anyFactory(test) : propsFactory(test)
      }

      if (typeof test === 'function') {
        return castFactory(test)
      }

      throw new Error('Expected function, string, or object as test')
    }
  )

/**
 * @param {Array<string | Props | TestFunctionAnything>} tests
 * @returns {AssertAnything}
 */
function anyFactory(tests) {
  /** @type {Array<AssertAnything>} */
  const checks = []
  let index = -1

  while (++index < tests.length) {
    checks[index] = convert(tests[index])
  }

  return castFactory(any)

  /**
   * @this {unknown}
   * @param {Array<unknown>} parameters
   * @returns {boolean}
   */
  function any(...parameters) {
    let index = -1

    while (++index < checks.length) {
      if (checks[index].call(this, ...parameters)) return true
    }

    return false
  }
}

/**
 * Turn an object into a test for a node with a certain fields.
 *
 * @param {Props} check
 * @returns {AssertAnything}
 */
function propsFactory(check) {
  return castFactory(all)

  /**
   * @param {Node} node
   * @returns {boolean}
   */
  function all(node) {
    /** @type {string} */
    let key

    for (key in check) {
      // @ts-expect-error: hush, it sure works as an index.
      if (node[key] !== check[key]) return false
    }

    return true
  }
}

/**
 * Turn a string into a test for a node with a certain type.
 *
 * @param {string} check
 * @returns {AssertAnything}
 */
function typeFactory(check) {
  return castFactory(type)

  /**
   * @param {Node} node
   */
  function type(node) {
    return node && node.type === check
  }
}

/**
 * Turn a custom test into a test for a node that passes that test.
 *
 * @param {TestFunctionAnything} check
 * @returns {AssertAnything}
 */
function castFactory(check) {
  return assertion

  /**
   * @this {unknown}
   * @param {unknown} node
   * @param {Array<unknown>} parameters
   * @returns {boolean}
   */
  function assertion(node, ...parameters) {
    return Boolean(
      node &&
        typeof node === 'object' &&
        'type' in node &&
        // @ts-expect-error: fine.
        Boolean(check.call(this, node, ...parameters))
    )
  }
}

function ok() {
  return true
}


/***/ }),

/***/ "./node_modules/rehype-minify-whitespace/skippable.js":
/*!************************************************************!*\
  !*** ./node_modules/rehype-minify-whitespace/skippable.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   skippable: () => (/* binding */ skippable)
/* harmony export */ });
const skippable = [
  'area',
  'base',
  'basefont',
  'dialog',
  'datalist',
  'head',
  'link',
  'meta',
  'noembed',
  'noframes',
  'param',
  'rp',
  'script',
  'source',
  'style',
  'template',
  'track',
  'title'
]


/***/ }),

/***/ "./node_modules/rehype-remark/index.js":
/*!*********************************************!*\
  !*** ./node_modules/rehype-remark/index.js ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   all: () => (/* reexport safe */ hast_util_to_mdast__WEBPACK_IMPORTED_MODULE_1__.all),
/* harmony export */   "default": () => (/* reexport safe */ _lib_index_js__WEBPACK_IMPORTED_MODULE_3__["default"]),
/* harmony export */   defaultHandlers: () => (/* reexport safe */ hast_util_to_mdast__WEBPACK_IMPORTED_MODULE_0__.handlers),
/* harmony export */   one: () => (/* reexport safe */ hast_util_to_mdast__WEBPACK_IMPORTED_MODULE_2__.one)
/* harmony export */ });
/* harmony import */ var hast_util_to_mdast__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! hast-util-to-mdast */ "./node_modules/hast-util-to-mdast/lib/handlers/index.js");
/* harmony import */ var hast_util_to_mdast__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! hast-util-to-mdast */ "./node_modules/hast-util-to-mdast/lib/all.js");
/* harmony import */ var hast_util_to_mdast__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! hast-util-to-mdast */ "./node_modules/hast-util-to-mdast/lib/one.js");
/* harmony import */ var _lib_index_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./lib/index.js */ "./node_modules/rehype-remark/lib/index.js");
/**
 * @typedef {import('hast-util-to-mdast').Context} Context
 * @typedef {import('hast-util-to-mdast').H} H
 * @typedef {import('hast-util-to-mdast').Handle} Handle
 * @typedef {import('./lib/index.js').Options} Options
 * @typedef {import('./lib/index.js').Processor} Processor
 */





/***/ }),

/***/ "./node_modules/rehype-remark/lib/index.js":
/*!*************************************************!*\
  !*** ./node_modules/rehype-remark/lib/index.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var hast_util_to_mdast__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! hast-util-to-mdast */ "./node_modules/hast-util-to-mdast/lib/index.js");
/**
 * @typedef {import('hast-util-to-mdast').Options} Options
 * @typedef {import('hast').Root} HastRoot
 * @typedef {import('mdast').Root} MdastRoot
 * @typedef {import('unified').Processor<any, any, any, any>} Processor
 */



/**
 * Plugin to bridge or mutate to rehype.
 *
 * If a destination is given, runs the destination with the new mdast
 * tree (bridge-mode).
 * Without destination, returns the mdast tree: further plugins run on that
 * tree (mutate-mode).
 *
 * @param destination
 *   Optional unified processor.
 * @param options
 *   Options passed to `hast-util-to-mdast`.
 */
const rehypeRemark =
  /**
   * @type {(import('unified').Plugin<[Processor, Options?], HastRoot> & import('unified').Plugin<[Options?]|void[], HastRoot, MdastRoot>)}
   */
  (
    /**
     * @param {Processor|Options} [destination]
     * @param {Options} [options]
     */
    function (destination, options) {
      /** @type {Options|undefined} */
      let settings
      /** @type {Processor|undefined} */
      let processor

      if (typeof destination === 'function') {
        processor = destination
        settings = options || {}
      } else {
        settings = destination || {}
      }

      if (settings.document === undefined || settings.document === null) {
        settings = Object.assign({}, settings, {document: true})
      }

      return processor ? bridge(processor, settings) : mutate(settings)
    }
  )

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (rehypeRemark);

/**
 * Bridge-mode.
 * Runs the destination with the new mdast tree.
 *
 * @type {import('unified').Plugin<[Processor, Options?], HastRoot>}
 */
function bridge(destination, options) {
  return (node, file, next) => {
    destination.run((0,hast_util_to_mdast__WEBPACK_IMPORTED_MODULE_0__.toMdast)(node, options), file, (error) => {
      next(error)
    })
  }
}

/**
 * Mutate-mode.
 * Further transformers run on the mdast tree.
 *
 * @type {import('unified').Plugin<[Options?]|void[], HastRoot, MdastRoot>}
 */
function mutate(options = {}) {
  return (node) => {
    const result = /** @type {MdastRoot} */ ((0,hast_util_to_mdast__WEBPACK_IMPORTED_MODULE_0__.toMdast)(node, options))
    return result
  }
}


/***/ }),

/***/ "./node_modules/trim-trailing-lines/index.js":
/*!***************************************************!*\
  !*** ./node_modules/trim-trailing-lines/index.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   trimTrailingLines: () => (/* binding */ trimTrailingLines)
/* harmony export */ });
/**
 * Remove final line endings from `value`
 *
 * @param {unknown} value
 *   Value with trailing line endings, coerced to string.
 * @return {string}
 *   Value without trailing line endings.
 */
function trimTrailingLines(value) {
  const input = String(value)
  let end = input.length

  while (end > 0) {
    const code = input.codePointAt(end - 1)
    if (code !== undefined && (code === 10 || code === 13)) {
      end--
    } else {
      break
    }
  }

  return input.slice(0, end)
}


/***/ }),

/***/ "./node_modules/unist-util-find-after/lib/index.js":
/*!*********************************************************!*\
  !*** ./node_modules/unist-util-find-after/lib/index.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   findAfter: () => (/* binding */ findAfter)
/* harmony export */ });
/* harmony import */ var unist_util_is__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! unist-util-is */ "./node_modules/unist-util-find-after/node_modules/unist-util-is/lib/index.js");
/**
 * @typedef {import('unist').Node} Node
 * @typedef {import('unist').Parent} Parent
 * @typedef {import('unist-util-is').Test} Test
 */



/**
 * Find the first node in `parent` after another `node` or after an index,
 * that passes `test`.

 * @param parent
 *   Parent node.
 * @param index
 *   Child of `parent` or it’s index.
 * @param test
 *   `unist-util-is`-compatible test.
 * @returns
 *   Child of `parent` or `null`.
 */
const findAfter =
  /**
   * @type {(
   *  (<T extends Node>(node: Parent, index: Node | number, test: import('unist-util-is').PredicateTest<T>) => T | null) &
   *  ((node: Parent, index: Node | number, test?: Test) => Node | null)
   * )}
   */
  (
    /**
     * @param {Parent} parent
     * @param {Node | number} index
     * @param {Test} [test]
     * @returns {Node | null}
     */
    function (parent, index, test) {
      const is = (0,unist_util_is__WEBPACK_IMPORTED_MODULE_0__.convert)(test)

      if (!parent || !parent.type || !parent.children) {
        throw new Error('Expected parent node')
      }

      if (typeof index === 'number') {
        if (index < 0 || index === Number.POSITIVE_INFINITY) {
          throw new Error('Expected positive finite number as index')
        }
      } else {
        index = parent.children.indexOf(index)

        if (index < 0) {
          throw new Error('Expected child node or index')
        }
      }

      while (++index < parent.children.length) {
        if (is(parent.children[index], index, parent)) {
          return parent.children[index]
        }
      }

      return null
    }
  )


/***/ }),

/***/ "./node_modules/unist-util-find-after/node_modules/unist-util-is/lib/index.js":
/*!************************************************************************************!*\
  !*** ./node_modules/unist-util-find-after/node_modules/unist-util-is/lib/index.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   convert: () => (/* binding */ convert),
/* harmony export */   is: () => (/* binding */ is)
/* harmony export */ });
/**
 * @typedef {import('unist').Node} Node
 * @typedef {import('unist').Parent} Parent
 */

/**
 * @typedef {Record<string, unknown>} Props
 * @typedef {null | undefined | string | Props | TestFunctionAnything | Array<string | Props | TestFunctionAnything>} Test
 *   Check for an arbitrary node, unaware of TypeScript inferral.
 *
 * @callback TestFunctionAnything
 *   Check if a node passes a test, unaware of TypeScript inferral.
 * @param {unknown} this
 *   The given context.
 * @param {Node} node
 *   A node.
 * @param {number | null | undefined} [index]
 *   The node’s position in its parent.
 * @param {Parent | null | undefined} [parent]
 *   The node’s parent.
 * @returns {boolean | void}
 *   Whether this node passes the test.
 */

/**
 * @template {Node} Kind
 *   Node type.
 * @typedef {Kind['type'] | Partial<Kind> | TestFunctionPredicate<Kind> | Array<Kind['type'] | Partial<Kind> | TestFunctionPredicate<Kind>>} PredicateTest
 *   Check for a node that can be inferred by TypeScript.
 */

/**
 * Check if a node passes a certain test.
 *
 * @template {Node} Kind
 *   Node type.
 * @callback TestFunctionPredicate
 *   Complex test function for a node that can be inferred by TypeScript.
 * @param {Node} node
 *   A node.
 * @param {number | null | undefined} [index]
 *   The node’s position in its parent.
 * @param {Parent | null | undefined} [parent]
 *   The node’s parent.
 * @returns {node is Kind}
 *   Whether this node passes the test.
 */

/**
 * @callback AssertAnything
 *   Check that an arbitrary value is a node, unaware of TypeScript inferral.
 * @param {unknown} [node]
 *   Anything (typically a node).
 * @param {number | null | undefined} [index]
 *   The node’s position in its parent.
 * @param {Parent | null | undefined} [parent]
 *   The node’s parent.
 * @returns {boolean}
 *   Whether this is a node and passes a test.
 */

/**
 * Check if a node is a node and passes a certain node test.
 *
 * @template {Node} Kind
 *   Node type.
 * @callback AssertPredicate
 *   Check that an arbitrary value is a specific node, aware of TypeScript.
 * @param {unknown} [node]
 *   Anything (typically a node).
 * @param {number | null | undefined} [index]
 *   The node’s position in its parent.
 * @param {Parent | null | undefined} [parent]
 *   The node’s parent.
 * @returns {node is Kind}
 *   Whether this is a node and passes a test.
 */

/**
 * Check if `node` is a `Node` and whether it passes the given test.
 *
 * @param node
 *   Thing to check, typically `Node`.
 * @param test
 *   A check for a specific node.
 * @param index
 *   The node’s position in its parent.
 * @param parent
 *   The node’s parent.
 * @returns
 *   Whether `node` is a node and passes a test.
 */
const is =
  /**
   * @type {(
   *   (() => false) &
   *   (<Kind extends Node = Node>(node: unknown, test: PredicateTest<Kind>, index: number, parent: Parent, context?: unknown) => node is Kind) &
   *   (<Kind extends Node = Node>(node: unknown, test: PredicateTest<Kind>, index?: null | undefined, parent?: null | undefined, context?: unknown) => node is Kind) &
   *   ((node: unknown, test: Test, index: number, parent: Parent, context?: unknown) => boolean) &
   *   ((node: unknown, test?: Test, index?: null | undefined, parent?: null | undefined, context?: unknown) => boolean)
   * )}
   */
  (
    /**
     * @param {unknown} [node]
     * @param {Test} [test]
     * @param {number | null | undefined} [index]
     * @param {Parent | null | undefined} [parent]
     * @param {unknown} [context]
     * @returns {boolean}
     */
    // eslint-disable-next-line max-params
    function is(node, test, index, parent, context) {
      const check = convert(test)

      if (
        index !== undefined &&
        index !== null &&
        (typeof index !== 'number' ||
          index < 0 ||
          index === Number.POSITIVE_INFINITY)
      ) {
        throw new Error('Expected positive finite index')
      }

      if (
        parent !== undefined &&
        parent !== null &&
        (!is(parent) || !parent.children)
      ) {
        throw new Error('Expected parent node')
      }

      if (
        (parent === undefined || parent === null) !==
        (index === undefined || index === null)
      ) {
        throw new Error('Expected both parent and index')
      }

      // @ts-expect-error Looks like a node.
      return node && node.type && typeof node.type === 'string'
        ? Boolean(check.call(context, node, index, parent))
        : false
    }
  )

/**
 * Generate an assertion from a test.
 *
 * Useful if you’re going to test many nodes, for example when creating a
 * utility where something else passes a compatible test.
 *
 * The created function is a bit faster because it expects valid input only:
 * a `node`, `index`, and `parent`.
 *
 * @param test
 *   *   when nullish, checks if `node` is a `Node`.
 *   *   when `string`, works like passing `(node) => node.type === test`.
 *   *   when `function` checks if function passed the node is true.
 *   *   when `object`, checks that all keys in test are in node, and that they have (strictly) equal values.
 *   *   when `array`, checks if any one of the subtests pass.
 * @returns
 *   An assertion.
 */
const convert =
  /**
   * @type {(
   *   (<Kind extends Node>(test: PredicateTest<Kind>) => AssertPredicate<Kind>) &
   *   ((test?: Test) => AssertAnything)
   * )}
   */
  (
    /**
     * @param {Test} [test]
     * @returns {AssertAnything}
     */
    function (test) {
      if (test === undefined || test === null) {
        return ok
      }

      if (typeof test === 'string') {
        return typeFactory(test)
      }

      if (typeof test === 'object') {
        return Array.isArray(test) ? anyFactory(test) : propsFactory(test)
      }

      if (typeof test === 'function') {
        return castFactory(test)
      }

      throw new Error('Expected function, string, or object as test')
    }
  )

/**
 * @param {Array<string | Props | TestFunctionAnything>} tests
 * @returns {AssertAnything}
 */
function anyFactory(tests) {
  /** @type {Array<AssertAnything>} */
  const checks = []
  let index = -1

  while (++index < tests.length) {
    checks[index] = convert(tests[index])
  }

  return castFactory(any)

  /**
   * @this {unknown}
   * @param {Array<unknown>} parameters
   * @returns {boolean}
   */
  function any(...parameters) {
    let index = -1

    while (++index < checks.length) {
      if (checks[index].call(this, ...parameters)) return true
    }

    return false
  }
}

/**
 * Turn an object into a test for a node with a certain fields.
 *
 * @param {Props} check
 * @returns {AssertAnything}
 */
function propsFactory(check) {
  return castFactory(all)

  /**
   * @param {Node} node
   * @returns {boolean}
   */
  function all(node) {
    /** @type {string} */
    let key

    for (key in check) {
      // @ts-expect-error: hush, it sure works as an index.
      if (node[key] !== check[key]) return false
    }

    return true
  }
}

/**
 * Turn a string into a test for a node with a certain type.
 *
 * @param {string} check
 * @returns {AssertAnything}
 */
function typeFactory(check) {
  return castFactory(type)

  /**
   * @param {Node} node
   */
  function type(node) {
    return node && node.type === check
  }
}

/**
 * Turn a custom test into a test for a node that passes that test.
 *
 * @param {TestFunctionAnything} check
 * @returns {AssertAnything}
 */
function castFactory(check) {
  return assertion

  /**
   * @this {unknown}
   * @param {unknown} node
   * @param {Array<unknown>} parameters
   * @returns {boolean}
   */
  function assertion(node, ...parameters) {
    return Boolean(
      node &&
        typeof node === 'object' &&
        'type' in node &&
        // @ts-expect-error: fine.
        Boolean(check.call(this, node, ...parameters))
    )
  }
}

function ok() {
  return true
}


/***/ }),

/***/ "./node_modules/unist-util-visit/lib/index.js":
/*!****************************************************!*\
  !*** ./node_modules/unist-util-visit/lib/index.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CONTINUE: () => (/* reexport safe */ unist_util_visit_parents__WEBPACK_IMPORTED_MODULE_0__.CONTINUE),
/* harmony export */   EXIT: () => (/* reexport safe */ unist_util_visit_parents__WEBPACK_IMPORTED_MODULE_0__.EXIT),
/* harmony export */   SKIP: () => (/* reexport safe */ unist_util_visit_parents__WEBPACK_IMPORTED_MODULE_0__.SKIP),
/* harmony export */   visit: () => (/* binding */ visit)
/* harmony export */ });
/* harmony import */ var unist_util_visit_parents__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! unist-util-visit-parents */ "./node_modules/unist-util-visit/node_modules/unist-util-visit-parents/lib/index.js");
/**
 * @typedef {import('unist').Node} Node
 * @typedef {import('unist').Parent} Parent
 * @typedef {import('unist-util-is').Test} Test
 * @typedef {import('unist-util-visit-parents').VisitorResult} VisitorResult
 */

/**
 * Check if `Child` can be a child of `Ancestor`.
 *
 * Returns the ancestor when `Child` can be a child of `Ancestor`, or returns
 * `never`.
 *
 * @template {Node} Ancestor
 *   Node type.
 * @template {Node} Child
 *   Node type.
 * @typedef {(
 *   Ancestor extends Parent
 *     ? Child extends Ancestor['children'][number]
 *       ? Ancestor
 *       : never
 *     : never
 * )} ParentsOf
 */

/**
 * @template {Node} [Visited=Node]
 *   Visited node type.
 * @template {Parent} [Ancestor=Parent]
 *   Ancestor type.
 * @callback Visitor
 *   Handle a node (matching `test`, if given).
 *
 *   Visitors are free to transform `node`.
 *   They can also transform `parent`.
 *
 *   Replacing `node` itself, if `SKIP` is not returned, still causes its
 *   descendants to be walked (which is a bug).
 *
 *   When adding or removing previous siblings of `node` (or next siblings, in
 *   case of reverse), the `Visitor` should return a new `Index` to specify the
 *   sibling to traverse after `node` is traversed.
 *   Adding or removing next siblings of `node` (or previous siblings, in case
 *   of reverse) is handled as expected without needing to return a new `Index`.
 *
 *   Removing the children property of `parent` still results in them being
 *   traversed.
 * @param {Visited} node
 *   Found node.
 * @param {Visited extends Node ? number | null : never} index
 *   Index of `node` in `parent`.
 * @param {Ancestor extends Node ? Ancestor | null : never} parent
 *   Parent of `node`.
 * @returns {VisitorResult}
 *   What to do next.
 *
 *   An `Index` is treated as a tuple of `[CONTINUE, Index]`.
 *   An `Action` is treated as a tuple of `[Action]`.
 *
 *   Passing a tuple back only makes sense if the `Action` is `SKIP`.
 *   When the `Action` is `EXIT`, that action can be returned.
 *   When the `Action` is `CONTINUE`, `Index` can be returned.
 */

/**
 * Build a typed `Visitor` function from a node and all possible parents.
 *
 * It will infer which values are passed as `node` and which as `parent`.
 *
 * @template {Node} Visited
 *   Node type.
 * @template {Parent} Ancestor
 *   Parent type.
 * @typedef {Visitor<Visited, ParentsOf<Ancestor, Visited>>} BuildVisitorFromMatch
 */

/**
 * Build a typed `Visitor` function from a list of descendants and a test.
 *
 * It will infer which values are passed as `node` and which as `parent`.
 *
 * @template {Node} Descendant
 *   Node type.
 * @template {Test} Check
 *   Test type.
 * @typedef {(
 *   BuildVisitorFromMatch<
 *     import('unist-util-visit-parents/complex-types.js').Matches<Descendant, Check>,
 *     Extract<Descendant, Parent>
 *   >
 * )} BuildVisitorFromDescendants
 */

/**
 * Build a typed `Visitor` function from a tree and a test.
 *
 * It will infer which values are passed as `node` and which as `parent`.
 *
 * @template {Node} [Tree=Node]
 *   Node type.
 * @template {Test} [Check=string]
 *   Test type.
 * @typedef {(
 *   BuildVisitorFromDescendants<
 *     import('unist-util-visit-parents/complex-types.js').InclusiveDescendant<Tree>,
 *     Check
 *   >
 * )} BuildVisitor
 */



/**
 * Visit nodes.
 *
 * This algorithm performs *depth-first* *tree traversal* in *preorder*
 * (**NLR**) or if `reverse` is given, in *reverse preorder* (**NRL**).
 *
 * You can choose for which nodes `visitor` is called by passing a `test`.
 * For complex tests, you should test yourself in `visitor`, as it will be
 * faster and will have improved type information.
 *
 * Walking the tree is an intensive task.
 * Make use of the return values of the visitor when possible.
 * Instead of walking a tree multiple times, walk it once, use `unist-util-is`
 * to check if a node matches, and then perform different operations.
 *
 * You can change the tree.
 * See `Visitor` for more info.
 *
 * @param tree
 *   Tree to traverse.
 * @param test
 *   `unist-util-is`-compatible test
 * @param visitor
 *   Handle each node.
 * @param reverse
 *   Traverse in reverse preorder (NRL) instead of the default preorder (NLR).
 * @returns
 *   Nothing.
 */
const visit =
  /**
   * @type {(
   *   (<Tree extends Node, Check extends Test>(tree: Tree, test: Check, visitor: BuildVisitor<Tree, Check>, reverse?: boolean | null | undefined) => void) &
   *   (<Tree extends Node>(tree: Tree, visitor: BuildVisitor<Tree>, reverse?: boolean | null | undefined) => void)
   * )}
   */
  (
    /**
     * @param {Node} tree
     * @param {Test} test
     * @param {Visitor} visitor
     * @param {boolean | null | undefined} [reverse]
     * @returns {void}
     */
    function (tree, test, visitor, reverse) {
      if (typeof test === 'function' && typeof visitor !== 'function') {
        reverse = visitor
        visitor = test
        test = null
      }

      (0,unist_util_visit_parents__WEBPACK_IMPORTED_MODULE_0__.visitParents)(tree, test, overload, reverse)

      /**
       * @param {Node} node
       * @param {Array<Parent>} parents
       */
      function overload(node, parents) {
        const parent = parents[parents.length - 1]
        return visitor(
          node,
          parent ? parent.children.indexOf(node) : null,
          parent
        )
      }
    }
  )




/***/ }),

/***/ "./node_modules/unist-util-visit/node_modules/unist-util-is/lib/index.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/unist-util-visit/node_modules/unist-util-is/lib/index.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   convert: () => (/* binding */ convert),
/* harmony export */   is: () => (/* binding */ is)
/* harmony export */ });
/**
 * @typedef {import('unist').Node} Node
 * @typedef {import('unist').Parent} Parent
 */

/**
 * @typedef {Record<string, unknown>} Props
 * @typedef {null | undefined | string | Props | TestFunctionAnything | Array<string | Props | TestFunctionAnything>} Test
 *   Check for an arbitrary node, unaware of TypeScript inferral.
 *
 * @callback TestFunctionAnything
 *   Check if a node passes a test, unaware of TypeScript inferral.
 * @param {unknown} this
 *   The given context.
 * @param {Node} node
 *   A node.
 * @param {number | null | undefined} [index]
 *   The node’s position in its parent.
 * @param {Parent | null | undefined} [parent]
 *   The node’s parent.
 * @returns {boolean | void}
 *   Whether this node passes the test.
 */

/**
 * @template {Node} Kind
 *   Node type.
 * @typedef {Kind['type'] | Partial<Kind> | TestFunctionPredicate<Kind> | Array<Kind['type'] | Partial<Kind> | TestFunctionPredicate<Kind>>} PredicateTest
 *   Check for a node that can be inferred by TypeScript.
 */

/**
 * Check if a node passes a certain test.
 *
 * @template {Node} Kind
 *   Node type.
 * @callback TestFunctionPredicate
 *   Complex test function for a node that can be inferred by TypeScript.
 * @param {Node} node
 *   A node.
 * @param {number | null | undefined} [index]
 *   The node’s position in its parent.
 * @param {Parent | null | undefined} [parent]
 *   The node’s parent.
 * @returns {node is Kind}
 *   Whether this node passes the test.
 */

/**
 * @callback AssertAnything
 *   Check that an arbitrary value is a node, unaware of TypeScript inferral.
 * @param {unknown} [node]
 *   Anything (typically a node).
 * @param {number | null | undefined} [index]
 *   The node’s position in its parent.
 * @param {Parent | null | undefined} [parent]
 *   The node’s parent.
 * @returns {boolean}
 *   Whether this is a node and passes a test.
 */

/**
 * Check if a node is a node and passes a certain node test.
 *
 * @template {Node} Kind
 *   Node type.
 * @callback AssertPredicate
 *   Check that an arbitrary value is a specific node, aware of TypeScript.
 * @param {unknown} [node]
 *   Anything (typically a node).
 * @param {number | null | undefined} [index]
 *   The node’s position in its parent.
 * @param {Parent | null | undefined} [parent]
 *   The node’s parent.
 * @returns {node is Kind}
 *   Whether this is a node and passes a test.
 */

/**
 * Check if `node` is a `Node` and whether it passes the given test.
 *
 * @param node
 *   Thing to check, typically `Node`.
 * @param test
 *   A check for a specific node.
 * @param index
 *   The node’s position in its parent.
 * @param parent
 *   The node’s parent.
 * @returns
 *   Whether `node` is a node and passes a test.
 */
const is =
  /**
   * @type {(
   *   (() => false) &
   *   (<Kind extends Node = Node>(node: unknown, test: PredicateTest<Kind>, index: number, parent: Parent, context?: unknown) => node is Kind) &
   *   (<Kind extends Node = Node>(node: unknown, test: PredicateTest<Kind>, index?: null | undefined, parent?: null | undefined, context?: unknown) => node is Kind) &
   *   ((node: unknown, test: Test, index: number, parent: Parent, context?: unknown) => boolean) &
   *   ((node: unknown, test?: Test, index?: null | undefined, parent?: null | undefined, context?: unknown) => boolean)
   * )}
   */
  (
    /**
     * @param {unknown} [node]
     * @param {Test} [test]
     * @param {number | null | undefined} [index]
     * @param {Parent | null | undefined} [parent]
     * @param {unknown} [context]
     * @returns {boolean}
     */
    // eslint-disable-next-line max-params
    function is(node, test, index, parent, context) {
      const check = convert(test)

      if (
        index !== undefined &&
        index !== null &&
        (typeof index !== 'number' ||
          index < 0 ||
          index === Number.POSITIVE_INFINITY)
      ) {
        throw new Error('Expected positive finite index')
      }

      if (
        parent !== undefined &&
        parent !== null &&
        (!is(parent) || !parent.children)
      ) {
        throw new Error('Expected parent node')
      }

      if (
        (parent === undefined || parent === null) !==
        (index === undefined || index === null)
      ) {
        throw new Error('Expected both parent and index')
      }

      // @ts-expect-error Looks like a node.
      return node && node.type && typeof node.type === 'string'
        ? Boolean(check.call(context, node, index, parent))
        : false
    }
  )

/**
 * Generate an assertion from a test.
 *
 * Useful if you’re going to test many nodes, for example when creating a
 * utility where something else passes a compatible test.
 *
 * The created function is a bit faster because it expects valid input only:
 * a `node`, `index`, and `parent`.
 *
 * @param test
 *   *   when nullish, checks if `node` is a `Node`.
 *   *   when `string`, works like passing `(node) => node.type === test`.
 *   *   when `function` checks if function passed the node is true.
 *   *   when `object`, checks that all keys in test are in node, and that they have (strictly) equal values.
 *   *   when `array`, checks if any one of the subtests pass.
 * @returns
 *   An assertion.
 */
const convert =
  /**
   * @type {(
   *   (<Kind extends Node>(test: PredicateTest<Kind>) => AssertPredicate<Kind>) &
   *   ((test?: Test) => AssertAnything)
   * )}
   */
  (
    /**
     * @param {Test} [test]
     * @returns {AssertAnything}
     */
    function (test) {
      if (test === undefined || test === null) {
        return ok
      }

      if (typeof test === 'string') {
        return typeFactory(test)
      }

      if (typeof test === 'object') {
        return Array.isArray(test) ? anyFactory(test) : propsFactory(test)
      }

      if (typeof test === 'function') {
        return castFactory(test)
      }

      throw new Error('Expected function, string, or object as test')
    }
  )

/**
 * @param {Array<string | Props | TestFunctionAnything>} tests
 * @returns {AssertAnything}
 */
function anyFactory(tests) {
  /** @type {Array<AssertAnything>} */
  const checks = []
  let index = -1

  while (++index < tests.length) {
    checks[index] = convert(tests[index])
  }

  return castFactory(any)

  /**
   * @this {unknown}
   * @param {Array<unknown>} parameters
   * @returns {boolean}
   */
  function any(...parameters) {
    let index = -1

    while (++index < checks.length) {
      if (checks[index].call(this, ...parameters)) return true
    }

    return false
  }
}

/**
 * Turn an object into a test for a node with a certain fields.
 *
 * @param {Props} check
 * @returns {AssertAnything}
 */
function propsFactory(check) {
  return castFactory(all)

  /**
   * @param {Node} node
   * @returns {boolean}
   */
  function all(node) {
    /** @type {string} */
    let key

    for (key in check) {
      // @ts-expect-error: hush, it sure works as an index.
      if (node[key] !== check[key]) return false
    }

    return true
  }
}

/**
 * Turn a string into a test for a node with a certain type.
 *
 * @param {string} check
 * @returns {AssertAnything}
 */
function typeFactory(check) {
  return castFactory(type)

  /**
   * @param {Node} node
   */
  function type(node) {
    return node && node.type === check
  }
}

/**
 * Turn a custom test into a test for a node that passes that test.
 *
 * @param {TestFunctionAnything} check
 * @returns {AssertAnything}
 */
function castFactory(check) {
  return assertion

  /**
   * @this {unknown}
   * @param {unknown} node
   * @param {Array<unknown>} parameters
   * @returns {boolean}
   */
  function assertion(node, ...parameters) {
    return Boolean(
      node &&
        typeof node === 'object' &&
        'type' in node &&
        // @ts-expect-error: fine.
        Boolean(check.call(this, node, ...parameters))
    )
  }
}

function ok() {
  return true
}


/***/ }),

/***/ "./node_modules/unist-util-visit/node_modules/unist-util-visit-parents/lib/color.browser.js":
/*!**************************************************************************************************!*\
  !*** ./node_modules/unist-util-visit/node_modules/unist-util-visit-parents/lib/color.browser.js ***!
  \**************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   color: () => (/* binding */ color)
/* harmony export */ });
/**
 * @param {string} d
 * @returns {string}
 */
function color(d) {
  return d
}


/***/ }),

/***/ "./node_modules/unist-util-visit/node_modules/unist-util-visit-parents/lib/index.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/unist-util-visit/node_modules/unist-util-visit-parents/lib/index.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CONTINUE: () => (/* binding */ CONTINUE),
/* harmony export */   EXIT: () => (/* binding */ EXIT),
/* harmony export */   SKIP: () => (/* binding */ SKIP),
/* harmony export */   visitParents: () => (/* binding */ visitParents)
/* harmony export */ });
/* harmony import */ var unist_util_is__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! unist-util-is */ "./node_modules/unist-util-visit/node_modules/unist-util-is/lib/index.js");
/* harmony import */ var _color_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./color.js */ "./node_modules/unist-util-visit/node_modules/unist-util-visit-parents/lib/color.browser.js");
/**
 * @typedef {import('unist').Node} Node
 * @typedef {import('unist').Parent} Parent
 * @typedef {import('unist-util-is').Test} Test
 */

/**
 * @typedef {boolean | 'skip'} Action
 *   Union of the action types.
 *
 * @typedef {number} Index
 *   Move to the sibling at `index` next (after node itself is completely
 *   traversed).
 *
 *   Useful if mutating the tree, such as removing the node the visitor is
 *   currently on, or any of its previous siblings.
 *   Results less than 0 or greater than or equal to `children.length` stop
 *   traversing the parent.
 *
 * @typedef {[(Action | null | undefined | void)?, (Index | null | undefined)?]} ActionTuple
 *   List with one or two values, the first an action, the second an index.
 *
 * @typedef {Action | ActionTuple | Index | null | undefined | void} VisitorResult
 *   Any value that can be returned from a visitor.
 */

/**
 * @template {Node} [Visited=Node]
 *   Visited node type.
 * @template {Parent} [Ancestor=Parent]
 *   Ancestor type.
 * @callback Visitor
 *   Handle a node (matching `test`, if given).
 *
 *   Visitors are free to transform `node`.
 *   They can also transform the parent of node (the last of `ancestors`).
 *
 *   Replacing `node` itself, if `SKIP` is not returned, still causes its
 *   descendants to be walked (which is a bug).
 *
 *   When adding or removing previous siblings of `node` (or next siblings, in
 *   case of reverse), the `Visitor` should return a new `Index` to specify the
 *   sibling to traverse after `node` is traversed.
 *   Adding or removing next siblings of `node` (or previous siblings, in case
 *   of reverse) is handled as expected without needing to return a new `Index`.
 *
 *   Removing the children property of an ancestor still results in them being
 *   traversed.
 * @param {Visited} node
 *   Found node.
 * @param {Array<Ancestor>} ancestors
 *   Ancestors of `node`.
 * @returns {VisitorResult}
 *   What to do next.
 *
 *   An `Index` is treated as a tuple of `[CONTINUE, Index]`.
 *   An `Action` is treated as a tuple of `[Action]`.
 *
 *   Passing a tuple back only makes sense if the `Action` is `SKIP`.
 *   When the `Action` is `EXIT`, that action can be returned.
 *   When the `Action` is `CONTINUE`, `Index` can be returned.
 */

/**
 * @template {Node} [Tree=Node]
 *   Tree type.
 * @template {Test} [Check=string]
 *   Test type.
 * @typedef {Visitor<import('./complex-types.js').Matches<import('./complex-types.js').InclusiveDescendant<Tree>, Check>, Extract<import('./complex-types.js').InclusiveDescendant<Tree>, Parent>>} BuildVisitor
 *   Build a typed `Visitor` function from a tree and a test.
 *
 *   It will infer which values are passed as `node` and which as `parents`.
 */




/**
 * Continue traversing as normal.
 */
const CONTINUE = true

/**
 * Stop traversing immediately.
 */
const EXIT = false

/**
 * Do not traverse this node’s children.
 */
const SKIP = 'skip'

/**
 * Visit nodes, with ancestral information.
 *
 * This algorithm performs *depth-first* *tree traversal* in *preorder*
 * (**NLR**) or if `reverse` is given, in *reverse preorder* (**NRL**).
 *
 * You can choose for which nodes `visitor` is called by passing a `test`.
 * For complex tests, you should test yourself in `visitor`, as it will be
 * faster and will have improved type information.
 *
 * Walking the tree is an intensive task.
 * Make use of the return values of the visitor when possible.
 * Instead of walking a tree multiple times, walk it once, use `unist-util-is`
 * to check if a node matches, and then perform different operations.
 *
 * You can change the tree.
 * See `Visitor` for more info.
 *
 * @param tree
 *   Tree to traverse.
 * @param test
 *   `unist-util-is`-compatible test
 * @param visitor
 *   Handle each node.
 * @param reverse
 *   Traverse in reverse preorder (NRL) instead of the default preorder (NLR).
 * @returns
 *   Nothing.
 */
const visitParents =
  /**
   * @type {(
   *   (<Tree extends Node, Check extends Test>(tree: Tree, test: Check, visitor: BuildVisitor<Tree, Check>, reverse?: boolean | null | undefined) => void) &
   *   (<Tree extends Node>(tree: Tree, visitor: BuildVisitor<Tree>, reverse?: boolean | null | undefined) => void)
   * )}
   */
  (
    /**
     * @param {Node} tree
     * @param {Test} test
     * @param {Visitor<Node>} visitor
     * @param {boolean | null | undefined} [reverse]
     * @returns {void}
     */
    function (tree, test, visitor, reverse) {
      if (typeof test === 'function' && typeof visitor !== 'function') {
        reverse = visitor
        // @ts-expect-error no visitor given, so `visitor` is test.
        visitor = test
        test = null
      }

      const is = (0,unist_util_is__WEBPACK_IMPORTED_MODULE_0__.convert)(test)
      const step = reverse ? -1 : 1

      factory(tree, undefined, [])()

      /**
       * @param {Node} node
       * @param {number | undefined} index
       * @param {Array<Parent>} parents
       */
      function factory(node, index, parents) {
        /** @type {Record<string, unknown>} */
        // @ts-expect-error: hush
        const value = node && typeof node === 'object' ? node : {}

        if (typeof value.type === 'string') {
          const name =
            // `hast`
            typeof value.tagName === 'string'
              ? value.tagName
              : // `xast`
              typeof value.name === 'string'
              ? value.name
              : undefined

          Object.defineProperty(visit, 'name', {
            value:
              'node (' + (0,_color_js__WEBPACK_IMPORTED_MODULE_1__.color)(node.type + (name ? '<' + name + '>' : '')) + ')'
          })
        }

        return visit

        function visit() {
          /** @type {ActionTuple} */
          let result = []
          /** @type {ActionTuple} */
          let subresult
          /** @type {number} */
          let offset
          /** @type {Array<Parent>} */
          let grandparents

          if (!test || is(node, index, parents[parents.length - 1] || null)) {
            result = toResult(visitor(node, parents))

            if (result[0] === EXIT) {
              return result
            }
          }

          // @ts-expect-error looks like a parent.
          if (node.children && result[0] !== SKIP) {
            // @ts-expect-error looks like a parent.
            offset = (reverse ? node.children.length : -1) + step
            // @ts-expect-error looks like a parent.
            grandparents = parents.concat(node)

            // @ts-expect-error looks like a parent.
            while (offset > -1 && offset < node.children.length) {
              // @ts-expect-error looks like a parent.
              subresult = factory(node.children[offset], offset, grandparents)()

              if (subresult[0] === EXIT) {
                return subresult
              }

              offset =
                typeof subresult[1] === 'number' ? subresult[1] : offset + step
            }
          }

          return result
        }
      }
    }
  )

/**
 * Turn a return value into a clean result.
 *
 * @param {VisitorResult} value
 *   Valid return values from visitors.
 * @returns {ActionTuple}
 *   Clean result.
 */
function toResult(value) {
  if (Array.isArray(value)) {
    return value
  }

  if (typeof value === 'number') {
    return [CONTINUE, value]
  }

  return [value]
}


/***/ })

}]);